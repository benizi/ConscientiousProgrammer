<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hackage on The Conscientious Programmer</title>
    <link>http://ConscientiousProgrammer.com/categories/hackage/</link>
    <description>Recent content in Hackage on The Conscientious Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Dec 2015 08:00:00 -0500</lastBuildDate>
    <atom:link href="http://ConscientiousProgrammer.com/categories/hackage/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>24 days of Hackage, 2015: day 6: finding utilities with Hoogle and Hayoo: MissingH, extra</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/06/24-days-of-hackage-2015-day-6-finding-utilities-with-hoogle-and-hayoo-missingh-extra/</link>
      <pubDate>Sun, 06 Dec 2015 08:00:00 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/06/24-days-of-hackage-2015-day-6-finding-utilities-with-hoogle-and-hayoo-missingh-extra/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-6:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Day 6&lt;/h2&gt;

&lt;p&gt;It will never be the case that everything everyone will find useful
will already be in the &amp;ldquo;standard library&amp;rdquo; for any language
ecosystem. However, one of the coolest features of the Haskell
ecosystem (which wows all non-Haskellers when I show them), is the ability to search for useful functions by type
signature, using &lt;a href=&#34;http://hoogle.haskell.org/&#34;&gt;&lt;code&gt;Hoogle&lt;/code&gt;&lt;/a&gt; or
&lt;a href=&#34;http://hayoo.fh-wedel.de/examples&#34;&gt;&lt;code&gt;Hayoo&lt;/code&gt;&lt;/a&gt;. You can use other
criteria also, such as names; this can be useful if you have a guess
at what some useful function might be named.&lt;/p&gt;

&lt;p&gt;There seem to be two philosophies as far as using other people&amp;rsquo;s
utility libraries (or even making one&amp;rsquo;s own to share between different
projects):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reuse is great, let&amp;rsquo;s do it&lt;/li&gt;
&lt;li&gt;every dependency is a potential liability, so it&amp;rsquo;s better to
reinvent, or copy and paste, rather than use something of uncertain
quality or maintainability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I tend to prefer reuse, but there have been times when I have copied
(and even modified) only just what I need, because I don&amp;rsquo;t want the
rest of what is inside a sprawling library that depends transitively
on a whole lot of stuff I don&amp;rsquo;t need. I think this is a granularity
issue. Many people have proposed the idea that since we have a Web
now, in theory the concept of &amp;ldquo;library&amp;rdquo; should go obsolete in favor of
micro-libraries, so to speak, maybe sometimes even to the level of
single standalone functions, and maybe even having a unique
identifier, but this topic is outside the scope of this article. (For
just one idea, check out Gabriel Gonzalez&amp;rsquo;s
&lt;a href=&#34;http://www.haskellforall.com/2015/05/the-internet-of-code.html&#34;&gt;&amp;ldquo;The internet of code&amp;rdquo;&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;The situation is also complicated by the fact that often, so much can
be reinvented with only a couple of lines of Haskell code, so why even
bother looking for someone&amp;rsquo;s implementation of it?&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s assume for this article that you are interested in finding
and using utility libraries. I show how to find some example functions
and reach two utility libraries that I use, very cleverly and
informatively named
&lt;a href=&#34;http://hackage.haskell.org/package/MissingH&#34;&gt;&lt;code&gt;MissingH&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;http://hackage.haskell.org/package/extra&#34;&gt;&lt;code&gt;extra&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;list-string-example:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;List/string example&lt;/h2&gt;

&lt;p&gt;A while ago I was manipulating strings (I was given &lt;code&gt;String&lt;/code&gt;, as
opposed to &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt;) and needed to replace all
occurrences of a substring in a file path with a different
substring. For example, as an HSpec test item for a hypothetical
function creatively named &lt;code&gt;replace&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all substrings within a string&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    replace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123abc123abc&amp;quot;&lt;/span&gt; `shouldBe` &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123d123d&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sure, it would not be hard to write code to do this, but why not use
see if it&amp;rsquo;s out there already for me to use?&lt;/p&gt;

&lt;p&gt;What type should we search for? Maybe&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;i.e.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ matching substring&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replacement for the match&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ original string&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ result string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK, let&amp;rsquo;s try this type as a
&lt;a href=&#34;http://hayoo.fh-wedel.de/?query=String+-%3E+String+-%3E+String+-%3E+String&#34;&gt;Hayoo search&lt;/a&gt;. Hmm,
the results are not too promising. At the top is some weird
undocumented regex thing, and that&amp;rsquo;s probably not what we want.&lt;/p&gt;

&lt;h2 id=&#34;an-important-search-technique-make-the-fewest-assumptions:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;An important search technique: make the fewest assumptions&lt;/h2&gt;

&lt;p&gt;Probably the single most important tip for getting good search results
from a type is to make the type as generic as possible: &lt;em&gt;the more type
variables, the better&lt;/em&gt;, and also use only type class constraints you
need. The operation we want is not really
string-specific. Rather, it was a list operation. So the real type we
want is&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This utility function makes the &lt;em&gt;least&lt;/em&gt; assumptions necessary to get
the job done, while working for &lt;code&gt;String&lt;/code&gt; because &lt;code&gt;String&lt;/code&gt; is just
&lt;code&gt;[Char]&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt; is an instance of the &lt;code&gt;Eq&lt;/code&gt; type class. But for the
purpose of replacements, we don&amp;rsquo;t care about whether we&amp;rsquo;re comparing
characters: we only care that whatever element type is involved in
these subsequences, we can compare for equality.&lt;/p&gt;

&lt;p&gt;The
&lt;a href=&#34;http://hayoo.fh-wedel.de/?query=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&#34;&gt;Hayoo search&lt;/a&gt;
immediately brings up much more promising results than with &lt;code&gt;String&lt;/code&gt;,
from packages such as &lt;code&gt;utility-ht&lt;/code&gt;, &lt;code&gt;MissingH&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt;. &lt;code&gt;pandoc&lt;/code&gt;
also popped up, but that&amp;rsquo;s a
&lt;a href=&#34;http://pandoc.org/&#34;&gt;huge text-processing tool&lt;/a&gt;, not a library I would
pull in for just one tiny utility function!&lt;/p&gt;

&lt;p&gt;The
&lt;a href=&#34;http://hoogle.haskell.org/?hoogle=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&amp;amp;scope=set%3Astackage&#34;&gt;Hoogle search at &lt;code&gt;hoogle.haskell.org&lt;/code&gt;&lt;/a&gt;
search works pretty well also. (Note that the Hoogle search at the old
site &lt;a href=&#34;https://www.haskell.org/hoogle/?hoogle=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&#34;&gt;gives bad results&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&#34;modifying-our-tests-to-check-the-function-with-the-more-generic-type:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Modifying our tests to check the function with the more generic type&lt;/h2&gt;

&lt;p&gt;I briefly mentioned refactoring HSpec tests on
&lt;a href=&#34;../../blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/&#34;&gt;day 3&lt;/a&gt;. Here&amp;rsquo;s
how to test multiple implementations of the same desired function
(let&amp;rsquo;s go with &lt;code&gt;MissingH&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt;), and also test &lt;code&gt;replace&lt;/code&gt; on
different input types: both &lt;code&gt;String&lt;/code&gt; (which is just &lt;code&gt;[Char]&lt;/code&gt;) and &lt;code&gt;[Int]&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MissingHExtraExampleSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | From MissingH&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.Utils&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; ListUtils

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | From extra&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.Extra&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; ListExtra

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Required for auto-discovery.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;MissingH and extra&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describeReplace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;MissingH&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ListUtils&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;replace
    describeReplace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;extra&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ListExtra&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;replace
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But the following fails to compile! Why?&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Fails to compile!&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ description&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a])  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt; description replace &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe description &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all substrings within a string&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      replace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123abc123abc&amp;quot;&lt;/span&gt; `shouldBe` &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123d123d&amp;quot;&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all int sublists within an int list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      replace [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] [&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;] [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;]
        `shouldBe` [&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;a-note-on-the-critical-use-of-higher-rank-types-for-refactoring:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;A note on the critical use of higher-rank types for refactoring&lt;/h3&gt;

&lt;p&gt;The error message is useful if you know what is going on, but not
useful but if not. Yes, we need higher-rank types.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;    Illegal polymorphic or qualified type:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    Perhaps you intended to use RankNTypes or Rank2Types&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    In the type signature for ‘describeReplace’:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      describeReplace :: String&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;                         -&amp;gt; (Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a]) -&amp;gt; Spec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Higher-rank types are a
supported GHC extension discussed in a
&lt;a href=&#34;https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html&#34;&gt;2014 Day of GHC Extensions&lt;/a&gt;. Higher-rank
types are tremendously useful and a feature that is missing from type
systems in most other languages.&lt;/p&gt;

&lt;p&gt;Briefly, the &lt;code&gt;replace&lt;/code&gt; function we want has the type&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;forall&lt;/span&gt; a&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;where we have explicitly quantified the type variable &lt;code&gt;a&lt;/code&gt; so that the
&lt;code&gt;Eq&lt;/code&gt; constraint applies inside its scope. Read the type as &amp;ldquo;for all
types &lt;code&gt;a&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; is a member of the &lt;code&gt;Eq&lt;/code&gt; type class, &lt;code&gt;[a] -&amp;gt;
[a] -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;&amp;rdquo;. Ordinary Haskell without the extension doesn&amp;rsquo;t
allow you to write down this type as a parameter into some function,
because it doesn&amp;rsquo;t have explicit &lt;code&gt;forall&lt;/code&gt; and implicitly inserts a
&lt;code&gt;forall&lt;/code&gt; for you at the top level for everything, but then that is the
wrong scoping for what we want to say.&lt;/p&gt;

&lt;p&gt;So we need to add the directive and change the &lt;code&gt;replace&lt;/code&gt; parameter
type to have explicit quantification, and all is OK:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE RankNTypes #-}&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ description&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (forall a&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a])  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-implicit-quantification-in-haskell-and-related-languages:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;A note on implicit quantification in Haskell and related languages&lt;/h3&gt;

&lt;p&gt;I kind of wish type variable quantification were explicit in Haskell,
i.e., &lt;em&gt;requiring&lt;/em&gt; &lt;code&gt;forall&lt;/code&gt; annotations, as
&lt;a href=&#34;http://www.purescript.org/&#34;&gt;PureScript&lt;/a&gt;
&lt;a href=&#34;https://github.com/purescript/purescript/wiki/Differences-from-Haskell&#34;&gt;does&lt;/a&gt;,
because understanding type variable quantification is important for
fully understanding what is going on at the type level in languages
such as ML and Haskell.&lt;/p&gt;

&lt;p&gt;For example, here&amp;rsquo;s a good article about
&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-03-27-unsafe.html&#34;&gt;how to understand the value restriction and monomorphism restriction&lt;/a&gt;,
which can be puzzling if you don&amp;rsquo;t have the mental model of what is going
on underneath.&lt;/p&gt;

&lt;h2 id=&#34;the-joy-of-browsing-libraries:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;The joy of browsing libraries&lt;/h2&gt;

&lt;p&gt;One thing that can happen if you find a utility function useful, is
you can browse around in the module that contains it, or the whole
library, just looking for stuff you might find useful in the
future. For example, I find Neil Mitchell&amp;rsquo;s &lt;code&gt;extra&lt;/code&gt; pleasant enough
(good names and great documentation on Hackage) that I use it when I
can, and I recommend checking it out. The GitHub repo of &lt;code&gt;MissingH&lt;/code&gt;
suggests that it is not really being updated any more, so I&amp;rsquo;m
downplaying my use of it.&lt;/p&gt;

&lt;p&gt;In the world of physical books and magazines, I still go to my local
libraries and browse both the new book/magazine/DVD shelves as well as
the look around on the shelf of an item I find in the stacks to see if
there&amp;rsquo;s something related that I might enjoy checking out.&lt;/p&gt;

&lt;h2 id=&#34;digging-more-deeply:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Digging more deeply&lt;/h2&gt;

&lt;p&gt;Also, note that if you&amp;rsquo;re on the hunt for possibly useful libraries,
but without an immediate need, you can also find them just by looking
at the dependency list that popular libraries already use. I confess
that I have sometimes clicked away on dependencies on a Hackage
page. If you transitively click around on Edward Kmett&amp;rsquo;s
&lt;a href=&#34;https://hackage.haskell.org/package/lens&#34;&gt;&lt;code&gt;lens&lt;/code&gt;&lt;/a&gt; dependencies, you
will reach a huge number of useful libraries, because he is the master
of the universe of code reuse.&lt;/p&gt;

&lt;p&gt;The physical book or paper analogy here, of course, is looking at the
references or bibliography to find more things to read.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For day 6, I gave an example of how to search for a function on Hoogle
and Hayoo, and go polymorphic for a good result. I recommend using the
quality &lt;code&gt;extra&lt;/code&gt; utility library.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 5: should-not-typecheck: making Haskell sort of dynamically typed with deferred type errors</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/05/24-days-of-hackage-2015-day-5-should-not-typecheck-making-haskell-sort-of-dynamically-typed-with-deferred-type-errors/</link>
      <pubDate>Sat, 05 Dec 2015 08:20:32 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/05/24-days-of-hackage-2015-day-5-should-not-typecheck-making-haskell-sort-of-dynamically-typed-with-deferred-type-errors/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-5:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Day 5&lt;/h2&gt;

&lt;p&gt;Have you ever been frustrated when using a statically typed language
because there&amp;rsquo;s a type error somewhere in your code base but you want
to run your program anyway, either because you don&amp;rsquo;t care about that
remote type error that has nothing to do with what you&amp;rsquo;re working on,
or because you want to step through your code and debug what the type
error really is? I certainly have.&lt;/p&gt;

&lt;p&gt;Also, have you ever wanted to write a unit test to verify that your
typed code disallows code you want to disallow, but you are
frustrated because how do you write code in a typed language that
says, &amp;ldquo;This code (that you won&amp;rsquo;t typecheck) won&amp;rsquo;t typecheck&amp;rdquo; and passes
the typechecker and runs?&lt;/p&gt;

&lt;p&gt;Welcome to the land of GHC&amp;rsquo;s
&lt;a href=&#34;https://ghc.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime&#34;&gt;&amp;ldquo;deferred type errors&amp;rdquo;&lt;/a&gt;,
a feature that has been part of GHC &lt;a href=&#34;https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/defer-type-errors.html&#34;&gt;since version 7.6.1&lt;/a&gt; in 2013. Since
this was not covered in Ollie&amp;rsquo;s
&lt;a href=&#34;https://ocharles.org.uk/blog/pages/2014-12-01-24-days-of-ghc-extensions.html&#34;&gt;2014 series &amp;ldquo;24 Days of GHC Extensions&amp;rdquo;&lt;/a&gt;,
I decided to bring it up here, and in the context of a cute package, &lt;a href=&#34;https://hackage.haskell.org/package/should-not-typecheck&#34;&gt;&lt;code&gt;should-not-typecheck&lt;/code&gt;&lt;/a&gt;
that hooks up with HSpec to make assertions that something won&amp;rsquo;t
typecheck.&lt;/p&gt;

&lt;h2 id=&#34;installation:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;Since LTS does not know about this obscure package, Stack helpfully
tells us exactly what to add to our &lt;code&gt;stack.yaml&lt;/code&gt; to bring it in:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;extra-deps:
- should-not-typecheck-2.0.1
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;let-s-write-some-tests:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Let&amp;rsquo;s write some tests&lt;/h2&gt;

&lt;p&gt;The full documentation of &lt;code&gt;should-not-typecheck&lt;/code&gt; is right there on
&lt;a href=&#34;https://hackage.haskell.org/package/should-not-typecheck&#34;&gt;its Hackage page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;First, we need to enable the GHC option &lt;code&gt;-fdefer-type-errors&lt;/code&gt; in the
test module, with a directive:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# OPTIONS_GHC -fdefer-type-errors #-}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;our-first-test:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Our first test&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ShouldNotTypecheckExample&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; ( &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;
                  , &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;
                  , &lt;span style=&#34;color: #0000FF&#34;&gt;shouldThrow&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;anyException&lt;/span&gt;
                  )
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.ShouldNotTypecheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;shouldNotTypecheck&lt;/span&gt;)

&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;should-not-typecheck&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;should not allow mapping negation over a list of strings&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      shouldNotTypecheck (map not [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;world&amp;quot;&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;That&amp;rsquo;s self-explanatory. We can&amp;rsquo;t do a Boolean negation on a
string. Haskell is not a &amp;ldquo;truthy&amp;rdquo;-based language, but a truth-based
language.&lt;/p&gt;

&lt;h2 id=&#34;some-puzzling-code:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Some puzzling code&lt;/h2&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the &lt;code&gt;ShouldNotTypecheckExample&lt;/code&gt; module:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# OPTIONS_GHC -fdefer-type-errors #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;ShouldNotTypecheckExample&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;thisWorks&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;thisFails&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;thisWorks&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;thisWorks&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  fst (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;world&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;True&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;!&amp;quot;&lt;/span&gt;])

&lt;span style=&#34;color: #0000FF&#34;&gt;thisFails&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;thisFails&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  snd (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;, [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;world&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;True&lt;/span&gt;, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;!&amp;quot;&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pause for a moment, and think of what should happen when &lt;code&gt;thisWorks&lt;/code&gt;
and &lt;code&gt;thisFails&lt;/code&gt; are used, and in what way, and why. In both cases, we
have a tuple and are returning the first element or the second element of
the tuple. The second element is a list that is clearly ill-typed,
because it contains something that is nonsensical (division of a
string by a boolean).&lt;/p&gt;

&lt;h2 id=&#34;the-role-of-laziness:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;The role of laziness&lt;/h2&gt;

&lt;p&gt;To understand what happens in the following tests, you need to
understand how laziness works in Haskell. The word &amp;ldquo;lazy&amp;rdquo; has come to
be used for many different ideas and constructs in different
programming languages, but Haskell&amp;rsquo;s &amp;ldquo;laziness&amp;rdquo; is unique. A full
discussion is outside the scope of this article, but I thought that
showing what happens with deferred type errors might be a gateway
toward better understanding the execution model of Haskell.&lt;/p&gt;

&lt;h3 id=&#34;never-reached:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Never reached&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;you can run code even if it contains ill-typed parts&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      thisWorks `shouldBe` &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This works because tuples in Haskell are lazy, and therefore in
ordinary typechecking, taking the first element of a well-typed tuple
succeeds no matter what is in the second element of the tuple. The
difference when operating in deferred typechecking mode is that the
tuple doesn&amp;rsquo;t even need to be well-typed, and the second element can
be complete junk, as it is here. So this example is straightforward if
you consider that what GHC does is somehow push the type error into a
reasonably small context so that outside of it, things still typecheck
and run normally.&lt;/p&gt;

&lt;h3 id=&#34;laziness-all-the-way-down:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Laziness all the way down&lt;/h3&gt;

&lt;p&gt;So what happens if we get the second element of the tuple, it is junk,
and take its length?&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;deferred type errors are only lazily reached&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      length thisFails `shouldBe` &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The answer is that everything is still fine, because the embedded list
inside the lazy tuple is a lazy list (because lists in Haskell are
lazy), and &lt;code&gt;length&lt;/code&gt; never looks at the elements of the list, only
counts their number, so it passes over the junky thunk for &lt;code&gt;&amp;quot;world&amp;quot; /
True&amp;quot;&lt;/code&gt; perfectly fine without needing to evaluate it.&lt;/p&gt;

&lt;h3 id=&#34;forcing-the-laziness:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Forcing the laziness&lt;/h3&gt;

&lt;p&gt;To explicitly force laziness into fully evaluated data (the kind of
data in standard programming languages), we need to use the
&lt;a href=&#34;https://hackage.haskell.org/package/deepseq&#34;&gt;&lt;code&gt;deepseq&lt;/code&gt;&lt;/a&gt; package. It&amp;rsquo;s
work to fully, deeply evaluate something in Haskell! We use
&lt;a href=&#34;https://hackage.haskell.org/package/deepseq-1.4.1.2/docs/Control-DeepSeq.html#v:force&#34;&gt;&lt;code&gt;force&lt;/code&gt;&lt;/a&gt;
from that package.&lt;/p&gt;

&lt;p&gt;In order to catch, in HSpec, the exception we expect to finally get, we
also need to use
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#v:evaluate&#34;&gt;&lt;code&gt;evaluate&lt;/code&gt;&lt;/a&gt;
from &lt;code&gt;Control.Exception&lt;/code&gt; in
&lt;a href=&#34;https://hackage.haskell.org/package/base&#34;&gt;&lt;code&gt;base&lt;/code&gt;&lt;/a&gt;, the main package
of the ecosystem (discussed
in a &lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-23-24-days-of-hackage-base.html&#34;&gt;2012 Day of Hackage post&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Exception&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;evaluate&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.DeepSeq&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;force&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Our test (which for simplicity is coarse in that it catches any
exception, rather than the specific typechecking exception):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;deferred type errors cause an exception only when reached&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      evaluate (force thisFails) `shouldThrow` anyException
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The deep evaluation will go all the way down to the junky expression
in the list in the tuple of our example, and a typechecking error is
thrown there at run time, as expected.&lt;/p&gt;

&lt;p&gt;Suppose we were just evaluating &lt;code&gt;thisFails&lt;/code&gt; from code, say within
GHCi. This is what we get:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; import ShouldNotTypecheckExample&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;*Main ShouldNotTypecheckExample&amp;gt; thisFails&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;&amp;quot;*** Exception: /Users/chen/Sync/haskell/twenty-four-days2015-of-hackage/src/ShouldNotTypecheckExample.hs:14:26:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    No instance for (Fractional Char) arising from a use of ‘/’&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    In the expression: &amp;quot;world&amp;quot; / True&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    In the expression: [&amp;quot;world&amp;quot; / True, &amp;quot;!&amp;quot;]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    In the first argument of ‘snd’, namely&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      ‘(&amp;quot;hello&amp;quot;, [&amp;quot;world&amp;quot; / True, &amp;quot;!&amp;quot;])’&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;(deferred type error)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;haskell-is-not-really-being-dynamic-here:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Haskell is not really being dynamic here&lt;/h2&gt;

&lt;p&gt;So is Haskell dynamically typed then, when running in this mode? Not
really. It&amp;rsquo;s faking it. What it&amp;rsquo;s basically doing is that the
typechecker is &lt;em&gt;still finding the type error at compile time&lt;/em&gt;, but
then secretly creating the exception information at the site of the
crappy code and replacing that code with a call to throw that
exception. The technical details are
&lt;a href=&#34;http://dreixel.net/research/pdf/epdtecp.pdf&#34;&gt;in this paper&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is completely different from the dynamic checking where nothing
is checked at compile time and an error is discovered during the
course of run time execution. Here, the error is discovered up front,
stashed away, and kept a secret until or unless it is demanded.&lt;/p&gt;

&lt;h2 id=&#34;for-more-on-laziness-and-forcing:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;For more on laziness and forcing&lt;/h2&gt;

&lt;p&gt;Simon Marlow&amp;rsquo;s free book
&lt;a href=&#34;http://chimera.labs.oreilly.com/books/1230000000929&#34;&gt;&amp;ldquo;Parallel and Concurrent Programming in Haskell&amp;rdquo;&lt;/a&gt;
has chapters on evaluation strategies, starting with &lt;a href=&#34;http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-sudoku2&#34;&gt;chapter 2&lt;/a&gt;. This stuff is subtle.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For day 5, I introduced the &lt;code&gt;should-not-typecheck&lt;/code&gt; package and briefly
discussed Haskell&amp;rsquo;s lazy evaluation and how it interacts with GHC&amp;rsquo;s
deferred type errors. A later Day of Hackage will venture into the
world of doing &amp;ldquo;real&amp;rdquo; dynamic typing in Haskell.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:60dd71330bbedef1aba1bef45daea5dd&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 4: wreq: Web client programming; with notes on lens and operator syntax</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/04/24-days-of-hackage-2015-day-4-wreq-web-client-programming-with-notes-on-lens-and-operator-syntax/</link>
      <pubDate>Fri, 04 Dec 2015 17:05:23 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/04/24-days-of-hackage-2015-day-4-wreq-web-client-programming-with-notes-on-lens-and-operator-syntax/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-4:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Day 4&lt;/h2&gt;

&lt;p&gt;In the late 1990s, I eagerly bought the book
&lt;a href=&#34;http://www.oreilly.com/openbook/webclient/&#34;&gt;&amp;ldquo;Web Client Programming with Perl&amp;rdquo;&lt;/a&gt;
and used the &lt;a href=&#34;http://search.cpan.org/dist/libwww-perl/lib/LWP.pm&#34;&gt;LWP&lt;/a&gt;
library to scrape the Web in automated fashion. I continued doing that
into the 2000s. I am happy that nowadays, I can just use Haskell to do
this kind of programming, in a succinct way also.&lt;/p&gt;

&lt;p&gt;Today&amp;rsquo;s topic is &lt;a href=&#34;http://www.serpentine.com/wreq/&#34;&gt;&lt;code&gt;wreq&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&#34;http://www.serpentine.com/blog/&#34;&gt;Bryan O&amp;rsquo;Sullivan&lt;/a&gt;&amp;rsquo;s high-level
library for doing Web client programming designed specifically for
usability.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wreq&lt;/code&gt; makes use of the
&lt;a href=&#34;https://hackage.haskell.org/package/aeson&#34;&gt;&lt;code&gt;aeson&lt;/code&gt;&lt;/a&gt; ecosystem for JSON
and &lt;a href=&#34;https://hackage.haskell.org/package/lens&#34;&gt;&lt;code&gt;lens&lt;/code&gt;&lt;/a&gt; and ecosystem,
including
&lt;a href=&#34;https://hackage.haskell.org/package/lens-aeson&#34;&gt;&lt;code&gt;lens-aeson&lt;/code&gt;&lt;/a&gt;, so you
may want to check out Ollie&amp;rsquo;s 2012 Days of Hackage posts on
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html&#34;&gt;aeson&lt;/a&gt;
and &lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-09-24-days-of-hackage-lens.html&#34;&gt;lens&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;wreq&lt;/code&gt; already has an extensive
&lt;a href=&#34;http://www.serpentine.com/wreq/&#34;&gt;tutorial and reference documentation&lt;/a&gt;,
I&amp;rsquo;m not going to repeat its explanations. Instead, I&amp;rsquo;m going to give an
example of use that should be simple enough to be understood from
context, then discuss the issue of using operator syntax in Haskell.&lt;/p&gt;

&lt;h2 id=&#34;the-task:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;The task&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m a member of many groups on &lt;a href=&#34;http://www.meetup.com/&#34;&gt;Meetup&lt;/a&gt;. It&amp;rsquo;s
often useful for me to get information using the official
&lt;a href=&#34;http://www.meetup.com/meetup_api/&#34;&gt;Meetup API&lt;/a&gt; rather than go around
clicking on a Web site on or a mobile app. Why do by hand what I can
do much more efficiently and correctly with code?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a very simplified example of something I might want to do with
Meetup. I&amp;rsquo;ve been active in the
&lt;a href=&#34;http://www.codeandsupply.co/&#34;&gt;Pittsburgh Code and Supply&lt;/a&gt; community,
which has a
&lt;a href=&#34;http://www.meetup.com/Pittsburgh-Code-Supply/&#34;&gt;Meetup site&lt;/a&gt; with a
packed calendar of events (it&amp;rsquo;s on hiatus now in December for the
holidays, but is otherwise very active). Maybe I want to find out what
upcoming events they are, and search for events of interest according
to some criteria. For our toy example here, let&amp;rsquo;s say I want to find
the ten upcoming events and get their names and venue names, and make
sure there&amp;rsquo;s at least one event that has a name and venue name already
set up (sometimes, an event is proposed but no venue has been found
yet).&lt;/p&gt;

&lt;h2 id=&#34;a-test:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;A test&lt;/h2&gt;

&lt;p&gt;Yesterday,
&lt;a href=&#34;../../blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/&#34;&gt;day 3&lt;/a&gt;
of this article series, I mentioned liking using HSpec, so let&amp;rsquo;s use
HSpec.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;WreqExample&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;eventName&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;venueName&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupEventInfos&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; ( &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;
                  , &lt;span style=&#34;color: #0000FF&#34;&gt;shouldSatisfy&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldNotSatisfy&lt;/span&gt;
                  )
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; Text
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We are using the &lt;a href=&#34;https://hackage.haskell.org/package/text&#34;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt;
packed Unicode string type, because that&amp;rsquo;s what &lt;code&gt;wreq&lt;/code&gt;
uses. &lt;code&gt;OverloadedStrings&lt;/code&gt; is a convenient GHC extension that allows
string literals in code to be treated as &lt;code&gt;Text&lt;/code&gt; values rather than
&lt;code&gt;String&lt;/code&gt;. Ollie discusses this extension in his &lt;a href=&#34;https://ocharles.org.uk/blog/posts/2014-12-17-overloaded-strings.html&#34;&gt;2014 Days of GHC Extensions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also, since I&amp;rsquo;m operating in test-driven development style, I wrote
this test first, before writing the &lt;code&gt;WreqExample&lt;/code&gt; module: I only wrote
the imports for what I need for the test.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;wreq&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;there are named, located Pittsburgh Code and Supply events coming up&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Warning! This is a stateful test going out to the Web.&lt;/span&gt;
      events &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getMeetupEventInfos pittsburghCodeAndSupplyId
      events `shouldNotSatisfy` null
      events `shouldSatisfy` any
        (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;event &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;null &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; eventName) event
                   &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;null &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; venueName) event)

&lt;span style=&#34;color: #0000FF&#34;&gt;pittsburghCodeAndSupplyId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;pittsburghCodeAndSupplyId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;13452572&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;module-signatures:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Module signatures&lt;/h2&gt;

&lt;p&gt;If Haskell had
&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-01-08-modules.html&#34;&gt;module signatures, like Standard ML and OCaml do&lt;/a&gt;,
I would write an explicit module signature for the module I intend to
implement that will conform to that signature, but Haskell doesn&amp;rsquo;t, so
the best we can do is operate in &amp;ldquo;duck typing&amp;rdquo; manner at the module
level, relying implicitly on compilation to fail on import of a
conforming module implementation rather than on matching against an
explicit signature without the need for an implementation.&lt;/p&gt;

&lt;p&gt;Here are the types we need (in a pseudo-syntax as though Haskell had
module signatures):&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- abstract&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- abstract&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- abstract type accessors&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;eventName&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;venueName&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupEventInfos&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;implementation:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Implementation&lt;/h2&gt;

&lt;h3 id=&#34;imports:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Imports&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Network.Wreq&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Options&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;defaults&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;param&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;getWith&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;asValue&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;responseBody&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Aeson&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Value&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Lens&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;view&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;set&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;toListOf&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Aeson.Lens&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;_Array&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;_String&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;types:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Types&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Information that we care about from a Meetup event.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt; { eventName &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
            , venueName &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
            }
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | A valid Meetup group ID.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;the-web-client-part:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;The Web client part&lt;/h3&gt;

&lt;p&gt;Since we&amp;rsquo;re only making one request, and are not doing any error
handling, but letting &lt;code&gt;wreq&lt;/code&gt; throw exceptions instead, the Web client
part is very brief. The Meetup API allows returning information as
JSON.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;meetupEventsUrl&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;meetupEventsUrl&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;https://api.meetup.com/2/events&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We perform a &lt;code&gt;GET&lt;/code&gt; with query parameters. &lt;code&gt;wreq&lt;/code&gt; uses lens as its
domain-specific language for creating options for &lt;code&gt;GET&lt;/code&gt;, so let&amp;rsquo;s
create a &lt;code&gt;wreq&lt;/code&gt; &lt;code&gt;Options&lt;/code&gt; value, by setting the parameters one after
another using a builder pattern starting with the &lt;code&gt;wreq&lt;/code&gt; &lt;code&gt;defaults&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;
              &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Options&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; groupId &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  set (param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;page&amp;quot;&lt;/span&gt;) [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;10&amp;quot;&lt;/span&gt;] (
    set (param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;order&amp;quot;&lt;/span&gt;) [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;] (
      set (param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;status&amp;quot;&lt;/span&gt;) [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;upcoming&amp;quot;&lt;/span&gt;] (
        set (param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;group_id&amp;quot;&lt;/span&gt;) [groupId] (
          set (param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;format&amp;quot;&lt;/span&gt;) [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;json&amp;quot;&lt;/span&gt;] defaults))))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We begin by going out to the Web to get back a response, which is a
&lt;a href=&#34;https://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html&#34;&gt;lazy &lt;code&gt;ByteString&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupEventInfos&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt;]
&lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupEventInfos&lt;/span&gt; groupId &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  response &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getWith (eventsOptions groupId) meetupEventsUrl
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;the-json-part:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;The JSON part&lt;/h3&gt;

&lt;p&gt;Then we parse the lazy &lt;code&gt;ByteString&lt;/code&gt; response, including the headers
and the body, into an untyped JSON object, an &lt;code&gt;aeson&lt;/code&gt;
&lt;a href=&#34;https://hackage.haskell.org/package/aeson-0.10.0.0/docs/Data-Aeson.html#t:Value&#34;&gt;&lt;code&gt;Value&lt;/code&gt;&lt;/a&gt;:
&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  jsonResponse &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; asValue response
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;More precisely, &lt;a href=&#34;https://hackage.haskell.org/package/aeson-0.10.0.0/docs/src/Data-Aeson-Types-Internal.html#Value&#34;&gt;&lt;code&gt;Value&lt;/code&gt; is unityped&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;HashMap&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Value&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Array&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Vector&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Value&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Value&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Object&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Object&lt;/span&gt;
           &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Array&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Array&lt;/span&gt;
           &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
           &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Number&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Scientific&lt;/span&gt;
           &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;
           &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;the-lens-part:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;The lens part&lt;/h3&gt;

&lt;p&gt;It was annoying figuring out from the official
Meetup API site what fields I needed from the response and what their
types were supposed to be. In practice I just saved off JSON from a
representative query and looked at some events to see what I wanted. I
was told where to find the
&lt;a href=&#34;meetup.json&#34;&gt;automatically generated documentation of all the API methods&lt;/a&gt;
but it was not ideal. A later Day of Hackage will discuss what I did
about this problem.&lt;/p&gt;

&lt;p&gt;We extract the list of events, using a traversal to get the whole
list, which is encoded as a JSON array in the top level JSON object&amp;rsquo;s
&lt;code&gt;results&lt;/code&gt; field:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; events &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; toListOf (responseBody
                         &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;results&amp;quot;&lt;/span&gt;
                         &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _Array &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; traverse
                        ) jsonResponse
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here we use &lt;code&gt;toListOf&lt;/code&gt; from lens with a traversal and a JSON object to
pull out everything from that traversal.&lt;/p&gt;

&lt;p&gt;Finally, since we only want, for each event, its name and
its venue&amp;rsquo;s name (the venue&amp;rsquo;s name is actually a field in a venue
object):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  return (map jsonToEventInfo events)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;We again use lens, at the level of an individual event object, to
extract what we want from it:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Extract our typed data model from an untyped JSON object.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;jsonToEventInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Value&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;jsonToEventInfo&lt;/span&gt; json &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;EventInfo&lt;/span&gt; { eventName &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; view (key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _String) json
            , venueName &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; view (key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;venue&amp;quot;&lt;/span&gt;
                                &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _String) json
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here we use the &lt;code&gt;view&lt;/code&gt; function of &lt;code&gt;lens&lt;/code&gt;, to apply a lens to the JSON
object to pull a field out of it.&lt;/p&gt;

&lt;p&gt;And we&amp;rsquo;re done! We&amp;rsquo;ve written a script that looks pretty much like
what you&amp;rsquo;d write in Perl or Python. It will also &amp;ldquo;fail&amp;rdquo; in similar
ways, because we&amp;rsquo;re basically not using any types at all; even the
final result just has strings, which may or may not be empty, whatever
that&amp;rsquo;s supposed to mean. For example, if you try to find a field by a
string key that doesn&amp;rsquo;t exist, the particular code here will just
silently give back an empty string. Can we do better? Yes, there are
various ways to do better. Stay tuned for a later Day of Hackage.&lt;/p&gt;

&lt;h2 id=&#34;lens-operator-syntax:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Lens operator syntax&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve already used &lt;code&gt;wreq&lt;/code&gt; or &lt;code&gt;lens&lt;/code&gt;, you may have noticed
something strange above: I didn&amp;rsquo;t use any &lt;code&gt;lens&lt;/code&gt; operator syntax. This
was deliberate. Although the &lt;code&gt;wreq&lt;/code&gt; tutorial gives a
&lt;a href=&#34;http://www.serpentine.com/wreq/tutorial.html#a-quick-lens-backgrounder&#34;&gt;little bit of background on &lt;code&gt;lens&lt;/code&gt;&lt;/a&gt;,
the reality is that when some friends who were not experienced lensers
or Haskellers asked me how I do Web client programming in Haskell, and
I pointed to &lt;code&gt;wreq&lt;/code&gt; as being pretty cool, they got immediately stuck
on the lens stuff. Looking back at the tutorial, I do see that it
jumps straight into operator soup. This is unfortunate. You can
immediately use libraries like &lt;code&gt;wreq&lt;/code&gt; without having the lens
operators memorized already. You have to understand some facts (such
as the use of the function composition operator to compose lenses) and
have an idea of how the types work out, but one thing you don&amp;rsquo;t need
is the funny operators. I think it&amp;rsquo;s best to understand how to do
things without operators before starting to use them as a convenient
shortcut.&lt;/p&gt;

&lt;p&gt;For example, an idiomatic way to set the options object, as presented
in the &amp;ldquo;whirlwind tour&amp;rdquo; section of the &lt;code&gt;wreq&lt;/code&gt; tutorial, is:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Lens&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;), (&lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt;))

&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;
              &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Options&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; groupId &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; defaults
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;format&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;json&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;group_id&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [groupId]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;status&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;upcoming&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;order&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;page&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;10&amp;quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t like the idea of newcomers to this library just copying and
pasting stuff without understanding what it does, or getting the
impression that these operators are somehow built into the Haskell
language or required for using the library. People really do get these
impressions.&lt;/p&gt;

&lt;p&gt;I happen to like the reverse function operator &lt;code&gt;&amp;amp;&lt;/code&gt; a lot, although
it&amp;rsquo;s not as suggestive as the exact same reverse function operator in
many other languages (such as F#, OCaml, Elm, Elixir) in the form of a pipe
instead
&lt;a href=&#34;http://package.elm-lang.org/packages/elm-lang/core/3.0.0/Basics#|%3E&#34;&gt;&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/a&gt;,
so I feel OK about using it.&lt;/p&gt;

&lt;p&gt;But the &lt;code&gt;.~&lt;/code&gt; is I think not very suggestive to newcomers to
&lt;code&gt;lens&lt;/code&gt;. Is &lt;code&gt;set lens newValue object&lt;/code&gt; so much worse to write or read than
&lt;code&gt;object &amp;amp; lens .~ newValue&lt;/code&gt;?&lt;/p&gt;

&lt;h2 id=&#34;code-golf:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Code golf?&lt;/h2&gt;

&lt;p&gt;To illustrate both the up sides and down sides of using operators (but
in this case mostly down sides, I think), here is a code golf version
of the entire code:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Network.Wreq&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Options&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;defaults&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;param&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;getWith&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;asValue&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;responseBody&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Lens&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt;), (&lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt;), (&lt;span style=&#34;color: #666666&#34;&gt;^.&lt;/span&gt;), (&lt;span style=&#34;color: #666666&#34;&gt;^..&lt;/span&gt;))
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Aeson.Lens&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;key&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;_Array&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;_String&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Arrow&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;), (&lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt;))

&lt;span style=&#34;color: #0000FF&#34;&gt;meetupEventsUrl&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;meetupEventsUrl&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;https://api.meetup.com/2/events&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | A valid Meetup group ID.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | For searching for events in a Meetup group.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt;
              &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Options&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;eventsOptions&lt;/span&gt; groupId &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; defaults
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;format&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;json&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;group_id&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [groupId]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;status&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;upcoming&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;order&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;]
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&lt;/span&gt; param &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;page&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.~&lt;/span&gt; [&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;10&amp;quot;&lt;/span&gt;]

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Code golf version. Don&amp;#39;t do this?&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupNameAndVenues&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;GroupId&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;)]
&lt;span style=&#34;color: #0000FF&#34;&gt;getMeetupNameAndVenues&lt;/span&gt; groupId &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  getWith (eventsOptions groupId) meetupEventsUrl
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; asValue
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;^..&lt;/span&gt; responseBody
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;results&amp;quot;&lt;/span&gt;
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _Array &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; traverse)
       &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; map ((&lt;span style=&#34;color: #666666&#34;&gt;^.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _String)
                 &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;^.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;venue&amp;quot;&lt;/span&gt;
                      &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; key &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;name&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; _String)
                 )
       &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; return
      )
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;In a way, this looks cool because the piping left to right reads well
and naturally, if you know all the operators and are happy with
operator sectioning syntax and point-free combinators. But when I
showed this to friends who are not so fluent in Haskell, they didn&amp;rsquo;t
like this. Also, note that I made concessions in order to arrange this
pipeline. I lost the comments, the intermediate named sub-computations
(very useful for finer-grained testing), and even my custom result
type (resorting to just tupling). I feel something has been lost by
writing in this style even though part of me secretly likes it.&lt;/p&gt;

&lt;h2 id=&#34;an-interview-with-bryan-o-sullivan:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;An interview with Bryan O&amp;rsquo;Sullivan&lt;/h2&gt;

&lt;p&gt;Recently (September 2015), &lt;a href=&#34;http://www.haskellcast.com/&#34;&gt;The Haskell Cast&lt;/a&gt; interviewed Bryan
O&amp;rsquo;Sullivan. I highly recommend listening to &lt;a href=&#34;http://www.haskellcast.com/episode/010-bryan-osullivan-on-performance-and-efficiency/&#34;&gt;the whole thing&lt;/a&gt;. He
had stories to tell about how he got into Haskell, how he ended up
writing all these libraries, and how he goes about designing them and
what his goals are when implementing them. Note that &lt;code&gt;aeson&lt;/code&gt; and
&lt;code&gt;text&lt;/code&gt;, which everyone uses, are his creations. Thank you, Bryan, for
all you&amp;rsquo;ve done for the Haskell community!&lt;/p&gt;

&lt;h2 id=&#34;lens-resources:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Lens resources&lt;/h2&gt;

&lt;p&gt;Gabriel Gonzalez wrote a
&lt;a href=&#34;https://hackage.haskell.org/package/lens-tutorial&#34;&gt;lens tutorial&lt;/a&gt;
that is useful. Thank you, Gabriel, for writing tutorials not only on
your own libraries, but for others as well!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For day 4, I presented a tiny example of use of &lt;code&gt;wreq&lt;/code&gt; with &lt;code&gt;aeson&lt;/code&gt;
and &lt;code&gt;lens&lt;/code&gt; to perform a simple task of getting information from the
Web, and tried to make &lt;code&gt;wreq&lt;/code&gt; more accessible by not requiring use of
&lt;code&gt;lens&lt;/code&gt; operators up front.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:de6d56fd6945d7d59fdd3a84148a0b85&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 3: HSpec; the importance of testing</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/</link>
      <pubDate>Thu, 03 Dec 2015 07:55:59 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-3:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Day 3&lt;/h2&gt;

&lt;p&gt;I spent my formative years writing software before &amp;ldquo;testing framework&amp;rdquo;
was in my vocabulary, before
&lt;a href=&#34;https://en.wikipedia.org/wiki/Test-driven_development&#34;&gt;&amp;ldquo;test-driven development&amp;rdquo;&lt;/a&gt;
was a thing. I shudder to think of those years, because now I&amp;rsquo;m a
believer in tests and even in test-driven development (TDD), according to my
interpretation of what that means (since everyone has a different
definition).&lt;/p&gt;

&lt;p&gt;There are a bunch of testing tools that have been available in the
Haskell ecosystem for some time. In fact, Ollie in his &amp;ldquo;24 Days of
Hackage&amp;rdquo; covered&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck&#34;&gt;&lt;code&gt;QuickCheck&lt;/code&gt;&lt;/a&gt;
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-08-24-days-of-hackage.html&#34;&gt;in 2012&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hackage.haskell.org/package/doctest&#34;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://ocharles.org.uk/blog/posts/2013-12-18-doctest.html&#34;&gt;in 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://documentup.com/feuerbach/tasty&#34;&gt;&lt;code&gt;tasty&lt;/code&gt;&lt;/a&gt; &lt;a href=&#34;https://ocharles.org.uk/blog/posts/2013-12-03-24-days-of-hackage-tasty.html&#34;&gt;in 2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and I heartily recommend looking those up.&lt;/p&gt;

&lt;p&gt;But today I&amp;rsquo;m going to show use of &lt;a href=&#34;http://hspec.github.io/&#34;&gt;&lt;code&gt;HSpec&lt;/code&gt;&lt;/a&gt;
(noting that a framework like &lt;code&gt;tasty&lt;/code&gt; or
&lt;a href=&#34;`https://batterseapower.github.io/test-framework/&#34;&gt;&lt;code&gt;test-framework&lt;/code&gt;&lt;/a&gt;
are a lot fancier).&lt;/p&gt;

&lt;h2 id=&#34;why-tests:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Why tests?&lt;/h2&gt;

&lt;p&gt;I first got into writing tests for two reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Using languages like Perl, it was essentially impossible to
be productive without writing tests.&lt;/li&gt;
&lt;li&gt;Such languages spawned the tooling to ease the pain of writing,
running, and getting feedback from tests.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But after getting started, I didn&amp;rsquo;t look back, even when using other
languages such as Scala and Haskell. Today, no matter what language
I&amp;rsquo;m using, I expect there to be a decent testing framework I can
immediately start using. I even did the experiment of
&lt;a href=&#34;http://conscientiousprogrammer.com/blog/2013/08/26/openhack-pittsburgh-learning-elixir-test-driven-and-package-publishing/&#34;&gt;learning a brand new language, Elixir, through writing tests&lt;/a&gt;. I
cannot take a language ecosystem seriously if there is not at least
some reasonable default standard testing framework that is part of it.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a myth (or joke) about using languages like Haskell that have
a decent type system: that you don&amp;rsquo;t need tests because you have
types. Hence the unfortunate phrase &amp;ldquo;tests versus types&amp;rdquo;. I completely
disagree with this. I want my types and I want my tests too: I want to
use every possible tool to help me design, verify, and troubleshoot my
code! At &lt;a href=&#34;http://pghtechfest.com/&#34;&gt;Pittsburgh TechFest&lt;/a&gt; 2014, I gave a
talk
&lt;a href=&#34;http://www.slideshare.net/FranklinChen/presentation-37257104&#34;&gt;&amp;ldquo;Exploring type-directed, test-driven development&amp;rdquo;&lt;/a&gt;
giving my personal view of making the best use of both types and tests
as part of an iterative process of refining understanding and
expression of a solution for a task
(this was before the term &amp;ldquo;type-directed development&amp;rdquo; became the title
of a coming book on using Idris,
&lt;a href=&#34;https://www.manning.com/books/type-driven-development-with-idris&#34;&gt;&amp;ldquo;Type-directed development with Idris&amp;rdquo;&lt;/a&gt;,
whose completion I look forward to!).&lt;/p&gt;

&lt;p&gt;The general topic of how best to combine types and tests is well
outside the scope of this article, but I just want to make one claim:
the primary benefits of tests come from their role as &lt;em&gt;explicit
documentation of intent during a design process&lt;/em&gt;. Ideally, we prefer to
write down expressive types to fully encode intent, and dependently
typed languages such as Idris enable transforming a lot of what used
to be runtime tests into compile-time tests encoded as type checking,
and you can do a bunch of this with Haskell already if you work hard
enough (and
&lt;a href=&#34;https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell&#34;&gt;Dependent Haskell&lt;/a&gt;
is in progress), but there is nothing wrong with writing tests today
that someday you might turn into types.&lt;/p&gt;

&lt;h3 id=&#34;breaking-news:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Breaking news!&lt;/h3&gt;

&lt;p&gt;By sheer coincidence, a
&lt;a href=&#34;https://blogs.janestreet.com/testing-with-expectations/&#34;&gt;new testing framework was just announced for OCaml&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;And today, right after I initially published this article, I found in
my news feed an announcement about &lt;a href=&#34;http://quickfuzz.org/&#34;&gt;QuickFuzz&lt;/a&gt;,
a grammar fuzz tester for Haskell!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s great that testing is being taken more seriously everywhere and by
everyone.&lt;/p&gt;

&lt;h2 id=&#34;why-hspec:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Why HSpec?&lt;/h2&gt;

&lt;p&gt;Why do I use HSpec, and not one of the fancier testing frameworks? I&amp;rsquo;m
not ruling out migrating to one of those in the future, but for now,
HSpec just feels really easy and comfortable to use, and is good
enough for me. I am so freaking lazy that I might not write tests if I
get intimidated by any possible sources of friction. And I&amp;rsquo;ll admit
that its &lt;a href=&#34;http://hspec.github.io/&#34;&gt;Web site&lt;/a&gt; is pretty good! Marketing
matters, I guess.&lt;/p&gt;

&lt;p&gt;Also, when I was using Ruby, I got accustomed to using
&lt;a href=&#34;http://rspec.info/&#34;&gt;RSpec&lt;/a&gt;, which of course was the inspiration for
HSpec.&lt;/p&gt;

&lt;h2 id=&#34;it-s-all-about-auto-discovery:740606311d3fcf0ba2f14607a358bd73&#34;&gt;It&amp;rsquo;s all about auto-discovery&lt;/h2&gt;

&lt;p&gt;Before even saying anything more about HSpec, I want to say that one
selling point of HSpec for me was auto-discovery. Check out the
&lt;a href=&#34;http://hspec.github.io/hspec-discover.html&#34;&gt;manual&lt;/a&gt; for full details.&lt;/p&gt;

&lt;p&gt;Auto-discovery means that given a simple boilerplate setup, you can
use &amp;ldquo;convention over configuration&amp;rdquo; and just give test module file
names matching &lt;code&gt;*Spec.hs&lt;/code&gt; and sticking them anywhere embedded inside
your &lt;code&gt;test/&lt;/code&gt; directory and they will all be picked up when you run
&lt;code&gt;stack test&lt;/code&gt;. This means being able to write test modules at will,
rename, delete, add, refactor them and not have to worry about
manually writing a boilerplate driver module that tediously imports
all the test modules and wires them up into a single project test
suite.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the setup I have for all my projects that use HSpec. I provide
it from my sample project template described on
&lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;,
so you can now generate a starter project with HSpec all ready to go
by running&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack new my-new-project franklinchen
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is a &lt;code&gt;test/&lt;/code&gt; directory with a single file in it, the
auto-discovery file named &lt;code&gt;test/Spec.hs&lt;/code&gt;, which has a single line of
code, actually a comment:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# OPTIONS_GHC -F -pgmF hspec-discover #-}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This works because when you have HSpec installed, a program
&lt;code&gt;hspec-discover&lt;/code&gt; also gets installed, and it&amp;rsquo;s called by GHC to do the
work of auto-discovery. Each test module should export &lt;code&gt;spec&lt;/code&gt;, because
that&amp;rsquo;s what the auto-discovery program will collect to call.&lt;/p&gt;

&lt;h2 id=&#34;writing-and-refactoring-tests:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Writing and refactoring tests&lt;/h2&gt;

&lt;p&gt;I didn&amp;rsquo;t mention it in
&lt;a href=&#34;../../blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/&#34;&gt;yesterday&amp;rsquo;s post about using a regex&lt;/a&gt;
to solve a problem, but when I wrote out examples of strings that are
supposed to match a regex and examples of strings that are not
supposed to match it, I simply copied and pasted those examples from
tests I had written.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s walk through writing &lt;code&gt;PCREHeavyExampleSpec.hs&lt;/code&gt;, step by
step.&lt;/p&gt;

&lt;h3 id=&#34;initial-version-of-test-code:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Initial version of test code&lt;/h3&gt;

&lt;p&gt;First, I&amp;rsquo;ll present code that I never actually wrote initially, because I
skipped this step and immediately refactored it in my mind. But I
decided that to showcase Haskell&amp;rsquo;s strength as a language for
embedding a domain-specific language (DSL), I retroactively wrote the
most obvious code that shows how HSpec works without introducing
non-HSpec considerations. (The code is on branch &lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage/tree/boilerplated-hspec&#34;&gt;&lt;code&gt;boilerplated-hspec&lt;/code&gt;&lt;/a&gt;.)&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PCREHeavyExampleSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PCREHeavyExample&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldSatisfy&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Regex.PCRE.Heavy&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt;))

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Required for auto-discovery.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;pcre-heavy&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has audio&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-audio,   audio&amp;quot;&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has video&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-video,video&amp;quot;&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has audio but missing&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-audio-but-missing, audio, missing&amp;quot;&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has video but unlinked&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-video-but-unlinked  , video,      unlinked&amp;quot;&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no audio or video&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;no-audio-or-video&amp;quot;&lt;/span&gt; `shouldSatisfy` (not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex))
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;missing media field&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;missing-media-field, unlinked&amp;quot;&lt;/span&gt; `shouldSatisfy` (not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The main thing to understand is that for simplest use (without
fixtures, effects, etc.), a basic description-labeled spec item is
introduced with &lt;code&gt;it&lt;/code&gt;, and a labeled &lt;code&gt;describe&lt;/code&gt; can contain many of
those as well as sub-&lt;code&gt;describe&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Here, we have two sub-&lt;code&gt;Spec&lt;/code&gt;s, one for examples that &lt;em&gt;should match&lt;/em&gt; the regex
and one for examples that &lt;em&gt;should not&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Note that we imported and used &lt;code&gt;mediaRegex&lt;/code&gt; from module
&lt;code&gt;PCREHeavyExample&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Unlike in our example program yesterday, which used &lt;code&gt;scan&lt;/code&gt; from
&lt;code&gt;pcre-heavy&lt;/code&gt; to collect match bindings, we only care whether something
matched, so we use its &lt;code&gt;=~&lt;/code&gt; operator instead that takes an input
string and a regex, and returns a &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The test code is concise enough, and the problem domain well
understood enough, that even if the syntax looks strange, I hope it is
clear &lt;em&gt;what&lt;/em&gt; is going on, even if not clear &lt;em&gt;how&lt;/em&gt; it&amp;rsquo;s being done.&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-syntax-in-haskell-code:740606311d3fcf0ba2f14607a358bd73&#34;&gt;A note on syntax in Haskell code&lt;/h3&gt;

&lt;p&gt;Now is a good time to talk about the issue of syntax in Haskell code,
because I&amp;rsquo;m expecting that if you are reading this, you might not
already be familiar with HSpec, and I also cannot assume that you are
already a seasoned Haskell developer, because I&amp;rsquo;m writing this article
series not for advanced Haskellers but for those starting to dip into
the library ecosystem and even friends with limited experience with
Haskell.&lt;/p&gt;

&lt;p&gt;It is convenient to use
&lt;a href=&#34;https://wiki.haskell.org/Section_of_an_infix_operator&#34;&gt;operator sectioning syntax&lt;/a&gt;
above, but I could have written&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;text&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;inputString &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; inputString &lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Furthermore, it is also convenient to use
&lt;a href=&#34;https://wiki.haskell.org/Infix_operator&#34;&gt;infix syntax for named functions&lt;/a&gt;
when sensible, but it is not required. I could have written in
bare-bones style&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;shouldSatisfy&lt;/span&gt; text (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;inputString &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; inputString &lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the cute &lt;code&gt;(not . (=~ mediaRegex))&lt;/code&gt; can be written as&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;inputString &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; not (inputString &lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I mention these facts about syntax because I have often been told by
people looking into Haskell that it&amp;rsquo;s confusing because of all the
operator syntax. But you don&amp;rsquo;t have to use this syntax if you don&amp;rsquo;t
want to: much that looks weird in Haskell is not something about the
language itself, but just about optional syntax for which there is
&amp;ldquo;normal&amp;rdquo; syntax if you prefer that. It&amp;rsquo;s not just about operators, but
about a lot of other optional syntax as well; if you are still
relatively new to Haskell syntax, Gabriel Gonzalez wrote a nice
&amp;ldquo;syntax decoding&amp;rdquo; tutorial covering some of that
&lt;a href=&#34;http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But saying &amp;ldquo;you don&amp;rsquo;t have to write it&amp;rdquo; is no use if &amp;ldquo;everyone is doing
it&amp;rdquo; and you have to &lt;em&gt;read&lt;/em&gt; it anyway. So it is the community as a whole
that sets the tone for what gets written and what gets read.&lt;/p&gt;

&lt;p&gt;One reason I like HSpec is that it does not go overboard with
syntax. &lt;a href=&#34;https://hackage.haskell.org/package/HUnit&#34;&gt;HUnit&lt;/a&gt;, an older
testing framework, provided funny operators that really turned me off,
such as
&lt;a href=&#34;https://hackage.haskell.org/package/HUnit-1.3.0.0/docs/Test-HUnit-Base.html&#34;&gt;&lt;code&gt;~=?&lt;/code&gt;&lt;/a&gt;. I
like Gabriel Gonzalez&amp;rsquo;s article
&lt;a href=&#34;http://www.haskellforall.com/2015/09/how-to-make-your-haskell-code-more.html&#34;&gt;&amp;ldquo;How to make your Haskell code more readable to non-Haskell programmers&amp;rdquo;&lt;/a&gt;. It
applies also to making the code more readable to experienced Haskell
programmers!&lt;/p&gt;

&lt;p&gt;I admit to having been guilty of some practices he calls out. I have
mixed feelings about giving them all up, all the time. For example, it
seems idiomatic to use the infix function operator &lt;code&gt;$&lt;/code&gt; for embedded
DSLs such HSpec, rather than parenthesize everything. I&amp;rsquo;m curious what
you think. Would you prefer to read the following, which is what the
&lt;code&gt;$&lt;/code&gt; operator avoids requiring?&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;pcre-heavy&amp;quot;&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match&amp;quot;&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has audio&amp;quot;&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-audio,   audio&amp;quot;&lt;/span&gt; `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
        )
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ...&lt;/span&gt;
      )
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ...&lt;/span&gt;
      )
    )
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I personally think that languages with a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; kind of block
(such as Pascal, Ruby) instead of braces or parentheses have an
advantage because that is more readable (to me), and recent research
&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2534973&#34;&gt;&amp;ldquo;An empirical investigation into programming language syntax&amp;rdquo;&lt;/a&gt;
claims to have evidence of this.&lt;/p&gt;

&lt;p&gt;Meanwhile, we make do with the language we have, and learn and teach
its quirks and features. It&amp;rsquo;s regrettable that English and Chinese are
really hard languages to use too, but we make do if we want to be part
of the community in the United States or in China. It goes both ways:
if we want to be part of the community, we have to invest in
understanding how it operates, and if the community wants to grow, it
has to reach out to newcomers rather than just say &amp;ldquo;you&amp;rsquo;re on your
own, deal with it&amp;rdquo;. Think of the immense amount of effort that goes
into promoting universal literacy.&lt;/p&gt;

&lt;h3 id=&#34;a-one-minute-review-of-test-driven-development:740606311d3fcf0ba2f14607a358bd73&#34;&gt;A one-minute review of test-driven development&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s continue with the test writing process.&lt;/p&gt;

&lt;p&gt;When doing test-driven development, we write an HSpec spec first,
&lt;em&gt;before even writing any implementation code&lt;/em&gt;. Test-driven development is
where you show how something is supposed to work before you actually
write that something. In a typed setting, this means we get a
compile-time error when first trying to run the test, which we fix by
creating &lt;code&gt;PCREHeavyExample&lt;/code&gt; as a new module with a stub:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;PCREHeavyExample&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; undefined
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, every test fails (in the terminal, the failures are
highlighted in red):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack &lt;span style=&#34;color: #008000&#34;&gt;test&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;PCREHeavyExample&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  pcre-heavy&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    match&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has audio FAILED [1]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has video FAILED [2]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has audio but missing FAILED [3]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has video but unlinked FAILED [4]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    no match&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      no audio or video FAILED [5]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      missing media field FAILED [6]&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;Failures:&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:13:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  1) PCREHeavyExample.pcre-heavy.match has audio&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:15:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  2) PCREHeavyExample.pcre-heavy.match has video&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:17:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  3) PCREHeavyExample.pcre-heavy.match has audio but missing&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:19:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  4) PCREHeavyExample.pcre-heavy.match has video but unlinked&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:22:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  5) PCREHeavyExample.pcre-heavy, no match, no audio or video&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;  test/PCREHeavyExampleSpec.hs:24:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  6) PCREHeavyExample.pcre-heavy, no match, missing media field&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.undefined)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;a-tangent-on-ghc-s-error-reporting:740606311d3fcf0ba2f14607a358bd73&#34;&gt;A tangent on GHC&amp;rsquo;s error reporting&lt;/h4&gt;

&lt;p&gt;A super-annoying thing, and a long-standing embarrassment for GHC, is
that using &lt;code&gt;undefined&lt;/code&gt; doesn&amp;rsquo;t trigger useful error reporting. I
look forward to
&lt;a href=&#34;https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1&#34;&gt;GHC 8.0&lt;/a&gt;&amp;rsquo;s
new feature of
&lt;a href=&#34;https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack/ImplicitLocations&#34;&gt;implicit parameters providing callstacks/source locations&lt;/a&gt;. This
stuff is important! It&amp;rsquo;s time we got line numbers and call stacks for
errors without having to jump through hoops.&lt;/p&gt;

&lt;h3 id=&#34;skipping-to-the-end-assume-we-finished-the-implementation:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Skipping to the end, assume we finished the implementation&lt;/h3&gt;

&lt;p&gt;OK, let&amp;rsquo;s assume we finished the implementation, which is simply
writing the regex for &lt;code&gt;mediaRegex&lt;/code&gt;. Then the tests pass (and in the
terminal they display in green):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;PCREHeavyExample&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  pcre-heavy&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    match&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has audio&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has video&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has audio but missing&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      has video but unlinked&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    no match&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      no audio or video&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      missing media field&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;Finished in 0.0010 seconds&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;6 examples, 0 failures&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;tests-are-code-too:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Tests are code too!&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s easy to not take test code seriously and not hold it up to the
same standards as &amp;ldquo;regular&amp;rdquo; code. That is a mistake: test code should
actually be cleaner and tighter than main implementation code because
it is our &lt;em&gt;executable documentation&lt;/em&gt; and what we need to make as easy
to read, write, and modify as requirements change.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-part-1:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Refactoring, part 1&lt;/h3&gt;

&lt;p&gt;Notice the tremendous amount of code duplication in the tests. We can
do better than this item-by-item copy-and-paste job. We can write code
to generate all the matching examples, by refactoring the relevant
data into a table and a function that maps over the table to get a
composite &lt;code&gt;Spec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is a table that pairs a test description with each example input
string:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;matchExamples&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;)]
&lt;span style=&#34;color: #0000FF&#34;&gt;matchExamples&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  [ ( &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has audio&amp;quot;&lt;/span&gt;
    , &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-audio,   audio&amp;quot;&lt;/span&gt;
    )
  , ( &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has video&amp;quot;&lt;/span&gt;
    , &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-video,video&amp;quot;&lt;/span&gt;
    )
  , ( &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has audio but missing&amp;quot;&lt;/span&gt;
    , &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-audio-but-missing, audio, missing&amp;quot;&lt;/span&gt;
    )
  , ( &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;has video but unlinked&amp;quot;&lt;/span&gt;
    , &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;@Media:&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;has-video-but-unlinked  , video,      unlinked&amp;quot;&lt;/span&gt;
    )
  ]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Here is a function that generates a spec item given a description/input pair.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;matchSpec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;matchSpec&lt;/span&gt; (description, text) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  it description &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    text `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Similarly for the non-matching examples.&lt;/p&gt;

&lt;p&gt;And the refactored &lt;code&gt;Spec&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;pcre-heavy&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      mapM_ matchSpec matchExamples
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      mapM_ nonMatchSpec nonMatchExamples
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;refactoring-part-2:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Refactoring, part 2&lt;/h3&gt;

&lt;p&gt;Uh oh, I said &amp;ldquo;similarly&amp;rdquo;. Usually when something is &amp;ldquo;similar&amp;rdquo;,
there&amp;rsquo;s more refactoring that might be doable.&lt;/p&gt;

&lt;p&gt;But &lt;strong&gt;Haskell makes refactoring joyful&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Haskell is a expressive language, where &amp;ldquo;might&amp;rdquo; usually means &amp;ldquo;can&amp;rdquo;,
and &amp;ldquo;can&amp;rdquo; often means &amp;ldquo;should&amp;rdquo;. In my experience, Haskell&amp;rsquo;s &lt;em&gt;single
best quality&lt;/em&gt; in terms of user experience is its support for
refactoring at will and with confidence that everything will still
mean exactly the same thing after as before the refactoring.&lt;/p&gt;

&lt;p&gt;I particularly look forward to the
ongoing development of a
&lt;a href=&#34;https://github.com/haskell/haskell-ide-engine&#34;&gt;universal Haskell IDE engine&lt;/a&gt;
refactoring even easier, e.g., folding in
&lt;a href=&#34;http://www.cs.kent.ac.uk/projects/refactor-fp/&#34;&gt;&lt;code&gt;HaRe&lt;/code&gt;&lt;/a&gt; support.&lt;/p&gt;

&lt;p&gt;We see a pattern of positive examples and negative examples using
a predicate and its negation. Let&amp;rsquo;s abstract this pattern out. Let&amp;rsquo;s
collect the positive and negative examples in one place. For
simplicity, let&amp;rsquo;s tuple them.&lt;/p&gt;

&lt;p&gt;And now that we&amp;rsquo;re dealing with arbitrary predicates, we no longer
have to hardcode &lt;code&gt;(=~ mediaRegex)&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; everywhere. We can &lt;em&gt;go
polymorphic&lt;/em&gt; in the predicate type, replacing &lt;code&gt;matchSpec&lt;/code&gt; and
&lt;code&gt;nonMatchSpec&lt;/code&gt; with a single &lt;code&gt;predSpec&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The final result:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describePredicate &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;pcre-heavy&amp;quot;&lt;/span&gt;
    (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match&amp;quot;&lt;/span&gt;, (&lt;span style=&#34;color: #666666&#34;&gt;=~&lt;/span&gt; mediaRegex))
    (matchExamples, nonMatchExamples)

&lt;span style=&#34;color: #0000FF&#34;&gt;describePredicate&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt;
     &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;                           &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ description&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;)              &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ (base description, predicate)&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; ( [(&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, a)], [(&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, a)] ) &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ positive and negative examples&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;describePredicate&lt;/span&gt; description
                  (baseDescription, predicate)
                  (positiveExamples, negativeExamples) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe description &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describe baseDescription &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      mapM_ (predSpec predicate) positiveExamples
    describe (&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;not &amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; baseDescription) &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      mapM_ (predSpec (not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; predicate)) negativeExamples

&lt;span style=&#34;color: #0000FF&#34;&gt;predSpec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, a) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;predSpec&lt;/span&gt; predicate (description, a) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  it description &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    a `shouldSatisfy` predicate
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;describePredicate&lt;/code&gt; and &lt;code&gt;predSpec&lt;/code&gt; can then be pulled out
into a test utilities module for use by other specs using the same
pattern.&lt;/p&gt;

&lt;p&gt;Unfortunately, this refactoring, although good in some ways, came with
a cost. It doesn&amp;rsquo;t look so great to me. Does it to you?&lt;/p&gt;

&lt;h3 id=&#34;refactoring-part-3:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Refactoring, part 3?&lt;/h3&gt;

&lt;p&gt;One reason the refactored code doesn&amp;rsquo;t actually look so great now is
that our refactoring led to many nested primitive types
(&lt;a href=&#34;http://c2.com/cgi/wiki?PrimitiveObsession&#34;&gt;&amp;ldquo;primitive obsession&amp;rdquo;&lt;/a&gt;)
and an explosion in number of positional arguments to our new
&lt;code&gt;describePredicate&lt;/code&gt;. Let&amp;rsquo;s face it, calling &lt;code&gt;describePredicate&lt;/code&gt; is
cryptic, calling out for &amp;ldquo;keyword arguments&amp;rdquo; (in a language that
supports them).&lt;/p&gt;

&lt;p&gt;In Haskell, &amp;ldquo;keyword arguments&amp;rdquo; means there&amp;rsquo;s a configuration data
type crying to be defined. A related code smell is that documenting
the parameters to &lt;code&gt;describePredicate&lt;/code&gt; is now super-awkward. Each of
those parameters should be a thing in itself, not just parenthesized,
bracketed, tupled glop.&lt;/p&gt;

&lt;p&gt;If we are really serious about refactoring, we should wrap these
things into new data types that are an explicit model of what we want
to do when classifying and testing examples.  We might even turn the
whole thing into its own embedded sub-DSL of HSpec.&lt;/p&gt;

&lt;p&gt;This illustrates how refactoring can sometimes lead to new complexity
that didn&amp;rsquo;t exist before. There are tradeoffs constantly. Abstraction
for its own sake does not always make things clearer. For this reason,
I did not actually go this far initially for the example code
yesterday: I did not feel it was worth the trouble. I&amp;rsquo;ve left it in
the &lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage/tree/refactoring-2&#34;&gt;&lt;code&gt;refactoring-2&lt;/code&gt;&lt;/a&gt; branch of the GitHub repo.&lt;/p&gt;

&lt;h2 id=&#34;combining-testing-frameworks:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Combining testing frameworks&lt;/h2&gt;

&lt;p&gt;One last thing about HSpec: you can use it within a larger testing
framework, or you can embed another testing framework into it as
well. For example, I like to use
&lt;a href=&#34;http://hspec.github.io/quickcheck.html&#34;&gt;QuickCheck through HSpec&lt;/a&gt; as
part of &amp;ldquo;type-directed development&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:740606311d3fcf0ba2f14607a358bd73&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Testing is important, but few love to do it. Making it easy to write
and use tests goes a long way toward actually doing it. I like HSpec
because it&amp;rsquo;s easy to write, and because of auto-discovery. I hope you
consider using it for your own projects if you don&amp;rsquo;t already use it or
some other testing framework.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:740606311d3fcf0ba2f14607a358bd73&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 2: Regexes with pcre-heavy; standalone Haskell scripts using Stack</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/</link>
      <pubDate>Wed, 02 Dec 2015 07:50:12 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-2:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Day 2&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t laugh, but once upon a time, I made Perl my main programming
language of choice (between around 1999 and 2010). There were many
reasons for this, but one reason was that Perl made it very easy to do
text processing using regexes.&lt;/p&gt;

&lt;p&gt;If you are a seasoned Haskeller, you might be thinking, &amp;ldquo;Why not use a
real parser instead?&amp;ldquo;, such as the venerable
&lt;a href=&#34;https://hackage.haskell.org/package/parsec&#34;&gt;parsec&lt;/a&gt;, which was covered in a
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html&#34;&gt;2012 day of Hackage&lt;/a&gt;?
(Or, today, one could consider one of several other newer alternative libraries
for parsing. A later day of Hackage will say more about this!)&lt;/p&gt;

&lt;p&gt;After all, Jamie Zawinski famously once wrote, &lt;em&gt;&amp;ldquo;Some people, when
confronted with a problem, think &amp;lsquo;I know, I&amp;rsquo;ll use regular
expressions.&amp;rsquo;  Now they have two problems.&amp;rdquo;&lt;/em&gt; I even gave a talk at
&lt;a href=&#34;http://pghtechfest.com/&#34;&gt;Pittsburgh Tech Fest&lt;/a&gt; in 2013,
&lt;a href=&#34;http://www.slideshare.net/FranklinChen/handout-22302440&#34;&gt;&amp;ldquo;Stop overusing regular expressions!&amp;rdquo;&lt;/a&gt;,
in which I promoted writing parsers rather than writing regexes.&lt;/p&gt;

&lt;p&gt;But, sometimes I do want to use a regex. In that case, I have been
using an obscure but useful package, &lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today I&amp;rsquo;ll show how to use &lt;code&gt;pcre-heavy&lt;/code&gt;, and while at it, also show
how to ship &lt;em&gt;one-file standalone Haskell scripts&lt;/em&gt; that only require
Stack.&lt;/p&gt;

&lt;h2 id=&#34;why-use-regexes-at-all:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Why use regexes at all?&lt;/h2&gt;

&lt;p&gt;Before going into &lt;code&gt;pcre-heavy&lt;/code&gt;, I thought I should explain when I use
regexes.&lt;/p&gt;

&lt;p&gt;Back when I was doing a lot of text extraction, cleaning, including
&lt;em&gt;correction&lt;/em&gt;, restructuring of messy data, regexes seemed the only
choice really. I had to not lose any &amp;ldquo;intended&amp;rdquo; information even if it
was obscured by garbage or misspellings or the like. I therefore could
not use some kind of approximate statistical technique, but had to
iteratively do do a lot exploratory work with some interactive
prompting in order to gradually clean up the data. Super-powerful
regex constructs of the Perl variety seemed perfect for this task.&lt;/p&gt;

&lt;p&gt;But even outside of such use cases, there&amp;rsquo;s no hiding from the fact
that regexes can be very convenient for simple tasks. Also,
because regexes are used so much in our programming world in general,
if we are migrating to Haskell some already-working regexes from
already-written code in some other language, it&amp;rsquo;s convenient to just
stick with regexes.&lt;/p&gt;

&lt;h2 id=&#34;which-haskell-regex-library-to-use:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Which Haskell regex library to use?!&lt;/h2&gt;

&lt;p&gt;A newcomer to Haskell must be overwhelmed by the lack of a single
standard library and syntax for regexes. I mean, take a look at this
&lt;a href=&#34;https://wiki.haskell.org/Regular_expressions&#34;&gt;wiki page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, I&amp;rsquo;m presenting
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;, a
regex library that I&amp;rsquo;ve been using when I want regexes at all (I try
not to want them). It&amp;rsquo;s pretty new and not even mentioned on that wiki
page.&lt;/p&gt;

&lt;p&gt;Some of my criteria for choosing a regex library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I want Perl-style regexes. That&amp;rsquo;s what I&amp;rsquo;m used to and are a kind of
standard across regex support in many programming languages.&lt;/li&gt;
&lt;li&gt;Nice syntax is a plus. One of the selling points of using regexes is
that the conciseness of writing patterns, binding matches,
etc. Without such conciseness, I just think &amp;ldquo;Why not just write a
real parser? It only takes a couple of lines in Haskell anyway.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;High performance is a perfectly legitimate reason to use regexes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given these criteria, using a &lt;a href=&#34;http://www.pcre.org/&#34;&gt;PCRE&lt;/a&gt;-based
library seemed the way to go. OK, the wiki page lists a bunch of
PCRE-based libraries.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/pcre-light&#34;&gt;&lt;code&gt;pcre-light&lt;/code&gt;&lt;/a&gt; is a
good way to go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It does require installation of the C library for
PCRE.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m mainly on Mac OS X, so I have PCRE installed through
Homebrew with &lt;code&gt;$ brew install pcre&lt;/code&gt;. I have PCRE working on
Linux. Unfortunately, I don&amp;rsquo;t use Windows, so if someone can verify
that &lt;code&gt;pcre-light&lt;/code&gt; installs OK on Windows, that would be great. I would
feel sad if I picked a library that is problematic for Windows users.&lt;/p&gt;

&lt;p&gt;Recently, out came
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;, a
wrapper around &lt;code&gt;pcre-light&lt;/code&gt; that uses
&lt;a href=&#34;https://wiki.haskell.org/Template_Haskell&#34;&gt;Template Haskell&lt;/a&gt;, and I
liked it, so I use it.&lt;/p&gt;

&lt;h2 id=&#34;example-program-using-pcre-heavy:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Example program using &lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pcre-heavy&lt;/code&gt; has decent documentation on
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;its Hackage page&lt;/a&gt;, so
I recommend reading that for the full details on how to use it. I&amp;rsquo;ll
give just a simple example here in the context of a complete program
that does something.&lt;/p&gt;

&lt;h3 id=&#34;specification-and-some-test-cases:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Specification and some test cases&lt;/h3&gt;

&lt;p&gt;Say we have a file of lines of text that are supposed to have a
comma-separated format of&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a fixed header&lt;/li&gt;
&lt;li&gt;a text transcript&amp;rsquo;s file path&lt;/li&gt;
&lt;li&gt;an &amp;ldquo;audio&amp;rdquo; or &amp;ldquo;video&amp;rdquo; field indicating the type of associated media&lt;/li&gt;
&lt;li&gt;an optional annotation about whether the associated media is missing
or not yet linked into the transcript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(I made up this example based on the structured text specification
called CHAT that happens to include a single line of this format,
e.g. &lt;a href=&#34;http://talkbank.org/data-orig/Meeting/SCOTUS/2008/08-205.cha&#34;&gt;this coded Supreme Court oral argument transcript for &amp;ldquo;Citizens United v. Federal Election Commission&amp;rdquo;&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Examples that should match:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;@Media:	has-audio,   audio
@Media:	has-video,video
@Media:	has-audio-but-missing, audio, missing
@Media:	has-video-but-unlinked  , video,      unlinked
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Examples that should fail to match:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;@Media:	no-audio-or-video
@Media:	missing-media-field, unlinked
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;creating-a-regex:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Creating a regex&lt;/h3&gt;

&lt;p&gt;Here is a &lt;code&gt;pcre-heavy&lt;/code&gt; regex, using the
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#v:re&#34;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt;
Template Haskell
&lt;a href=&#34;https://wiki.haskell.org/Template_Haskell#QuasiQuoters&#34;&gt;quasiquoter&lt;/a&gt;
that builds a PCRE-compiled
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#t:Regex&#34;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [re&lt;span style=&#34;color: #666666&#34;&gt;|^@&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Media:\&lt;/span&gt;t([&lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ,]&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;)&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(audio&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;video)(&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;?:&lt;/span&gt;missing&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;unlinked))&lt;span style=&#34;color: #666666&#34;&gt;?|&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;regex-string-validated-at-haskell-compile-time:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Regex string validated at Haskell compile-time&lt;/h2&gt;

&lt;p&gt;One selling point of &lt;code&gt;pcre-heavy&lt;/code&gt; for me is that because it uses
Template Haskell, a bad regex string results in a Haskell-level
compile-time error rather than a runtime error.&lt;/p&gt;

&lt;p&gt;Example of a compile-time error:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- This Haskell code fails to compile!&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [re&lt;span style=&#34;color: #666666&#34;&gt;|^@&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Media:\&lt;/span&gt;t([&lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ,]&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;)&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(audio&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;video)(&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;?:&lt;/span&gt;missing&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;unlinked)&lt;span style=&#34;color: #666666&#34;&gt;?|&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Loading this in GHCi or compiling with GHC results in&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;    Exception when trying to run compile-time code:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      Text.Regex.PCRE.Light: Error in regex: missing )&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    Code: template-haskell-2.10.0.0:Language.Haskell.TH.Quote.quoteExp&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;            re&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;            &amp;quot;^@Media:\\t([^ ,]+)\\ *,\\ *(audio|video)(\\ *,\\ *(?:missing|unlinked)?&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;using-the-regex:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Using the regex&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll use
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#v:scan&#34;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;
to extract the matches (if any) against our regex on a string.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; returns a lazy list of all possible matches:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Simplified type signature for our purposes.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;scan&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;])]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each match is a pair &lt;code&gt;(String, [String])&lt;/code&gt;, where the first component
is the whole string that matched, and the second is an ordered list of
parenthesized groupings in the regex. In our regex, we had three
parenthesized groupings, so a match could result in a three-element
grouping list:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; scan mediaRegex &amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;[(&amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;,[&amp;quot;foo&amp;quot;,&amp;quot;audio&amp;quot;,&amp;quot;, unlinked&amp;quot;])]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since we only want
the first match (if any), we can just compose it with
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Maybe.html#v:listToMaybe&#34;&gt;&lt;code&gt;listToMaybe&lt;/code&gt; from &lt;code&gt;Data.Maybe&lt;/code&gt;&lt;/a&gt;,
which has type&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;listToMaybe&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;so &lt;code&gt;listToMaybe . scan mediaRegex&lt;/code&gt; has type &lt;code&gt;String -&amp;gt; Maybe (String, [String])&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; (listToMaybe . scan mediaRegex) &amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Just (&amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;,[&amp;quot;foo&amp;quot;,&amp;quot;audio&amp;quot;,&amp;quot;, unlinked&amp;quot;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;extracting-useful-information:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Extracting useful information&lt;/h2&gt;

&lt;p&gt;Finally, what we really wanted to do after matching is apply
additional business logic and get stuff into a real type as soon as
possible, rather than engage in &amp;ldquo;stringly-typed&amp;rdquo; programming and
context-dependent list lengths.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that for our task, we only care about matched lines that are
&lt;em&gt;not&lt;/em&gt; missing or unlinked, and skip those that are missing or
unlinked. We define a data type and use pattern matching to get out of
the untyped world into the typed world of our data model.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Extract information about a media file if it is present.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;presentation-as-a-report:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Presentation as a report&lt;/h2&gt;

&lt;p&gt;Finally, now that we are done with the regex world, and have a data
model, all that is left is a driver to complete an example
command-line program.&lt;/p&gt;

&lt;p&gt;We have all the information needed to print out a report for each line.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Output a report.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Nothing&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match, but missing or unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;And the final driver, piping everything through from standard input:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  s &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getContents
  mapM_ (reportOnInfo
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; fmap extractIfPresent
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; listToMaybe
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; scan mediaRegex
       ) (lines s)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;using-stack-to-ship-standalone-scripts:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Using Stack to ship standalone scripts&lt;/h2&gt;

&lt;p&gt;We can try our program from within the GHCi REPL by just typing &lt;code&gt;main&lt;/code&gt;
or &lt;code&gt;:main&lt;/code&gt; at the REPL prompt and typing in lines of text. We can also
do &lt;code&gt;stack build&lt;/code&gt; to native-compile into a shippable binary.&lt;/p&gt;

&lt;p&gt;But another option is to ship the source code as a standalone one-file
script. This can be very convenient in some circumstances, when you
can rely on the recipient simply installing Stack.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how we can turn our program into such a standalone script: just
add the following two lines and make the file executable:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;#!/&lt;/span&gt;usr&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;bin&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;env stack
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- stack --resolver lts-3.16 --install-ghc runghc --package pcre-heavy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Stack will read the embedded command in order to install GHC, if
 needed, and first download and install the packages listed (here
 &lt;code&gt;pcre-heavy&lt;/code&gt;), if needed. We have pinned down the exact version of
 LTS in order to guarantee what versions of everything will be used by
 Stack. (Note: in this case, because of FFI with a
 C library, the recipient has to install PCRE first.)&lt;/p&gt;

&lt;p&gt;So if you have short programs that don&amp;rsquo;t need to be organized into
full-scale Cabal projects, you can treat Haskell as a &amp;ldquo;scripting
language&amp;rdquo; with full access to the libraries of Hackage!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; app/PCREHeavyExampleMain.hs &amp;lt; input.txt &amp;gt; output.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;a-warning:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;A warning&lt;/h3&gt;

&lt;p&gt;Although this Stack-as-Haskell-interpreter feature is kind of cool, I
prefer to write modular, separately testable libraries, while having
the &lt;code&gt;main&lt;/code&gt; driver of the &lt;code&gt;Main&lt;/code&gt; module of a program just use library
modules that do most of the real work. Furthermore, I prefer to build
and use native-compiled libraries and binaries because they&amp;rsquo;re just
much faster to start up and also run: &lt;code&gt;runghc&lt;/code&gt; is a Haskell
interpreter rather than a native optimizing compiler. But the beauty
of the GHC Haskell world is you can run in either mode, and flip from
one to the other seamlessly.&lt;/p&gt;

&lt;h3 id=&#34;here-s-our-complete-example-standalone-program:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Here&amp;rsquo;s our complete example standalone program&lt;/h3&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;#!/&lt;/span&gt;usr&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;bin&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;env stack
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- stack --resolver lts-3.16 --install-ghc runghc --package pcre-heavy&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE QuasiQuotes #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Main&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Regex.PCRE.Heavy&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;re&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;scan&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Maybe&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;listToMaybe&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Printf&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;printf&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Match a media name, audio/video, and optional missing/unlinked.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [re&lt;span style=&#34;color: #666666&#34;&gt;|^@&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Media:\&lt;/span&gt;t([&lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ,]&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;)&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(audio&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;video)(&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;?:&lt;/span&gt;missing&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;unlinked))&lt;span style=&#34;color: #666666&#34;&gt;?|&lt;/span&gt;]

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Extract information about a media file if it is present.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Output a report.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Nothing&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match, but missing or unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Driver, in traditional right-to-left syntax.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  s &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getContents
  mapM_ (reportOnInfo
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; fmap extractIfPresent
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; listToMaybe
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; scan mediaRegex
       ) (lines s)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;some-additional-notes:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Some additional notes&lt;/h2&gt;

&lt;p&gt;One limitation faced by a short expository article with example code
is that we don&amp;rsquo;t like to waste space and attention, and therefore tend
to present quick-and-dirty code, rather than production-level code
(which is efficient, has sensible error recovery, well-commented). I&amp;rsquo;ve
been thinking about the dilemma of &lt;em&gt;how not to give the
wrong impression and set a bad example by showing simplistic example
code&lt;/em&gt;. There&amp;rsquo;s no easy answer, but I felt it might be useful to
provide optional &amp;ldquo;advanced&amp;rdquo; notes sometimes, on how to write real code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pcre-heavy&lt;/code&gt; allows matching not only of &lt;code&gt;String&lt;/code&gt;, but also of
&lt;code&gt;ByteString&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; types. In practice, for efficiency, we
want to use
&lt;a href=&#34;http://hackage.haskell.org/package/bytestring&#34;&gt;&lt;code&gt;bytestring&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;http://hackage.haskell.org/package/text&#34;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt; as much as possible,
rather than the inefficient &lt;code&gt;String&lt;/code&gt; type. (&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-12-24-days-of-hackage-text.html&#34;&gt;A 2012 day of hackage
article talks about &lt;code&gt;text&lt;/code&gt;&lt;/a&gt;.)
Since the underlying PCRE C library uses bytes, I generally hand
bytestrings to &lt;code&gt;pcre-heavy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The sample driver code uses lazy I/O to get the lines from input. This
is superficially elegant and concise for pedagogical purposes, but in
real life is a source of resource leaks and other problems and even
causes people to think &amp;ldquo;Haskell is inefficient&amp;rdquo;. For real work, I like
to use &lt;a href=&#34;http://hackage.haskell.org/package/pipes&#34;&gt;&lt;code&gt;pipes&lt;/code&gt;&lt;/a&gt;, which was
covered in another
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-16-24-days-of-hackage-pipes.html&#34;&gt;2012 day of Hackage&lt;/a&gt;
and also has an
&lt;a href=&#34;https://hackage.haskell.org/package/pipes-4.1.7/docs/Pipes-Tutorial.html&#34;&gt;extensive, beautiful tutorial&lt;/a&gt;
by its author, Gabriel Gonzalez, who also has a fantastic,
long-running, active blog
&lt;a href=&#34;http://www.haskellforall.com/&#34;&gt;&amp;ldquo;Haskell for all&amp;rdquo;&lt;/a&gt; that every
Haskeller should follow.&lt;/p&gt;

&lt;p&gt;Finally, was a regex the right choice here? It was simple enough for
this problem, but you can see from the ad hoc pattern matching and
hardcoded strings and fragile positional ordering and number of groups
that things could get error-prone really quickly if the regex got any
more complex or we wanted to do proper error handling in case of a
failed match.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Regex support is not a strong point of the Haskell ecosystem, which is
geared to more structured parsing, but there are options if you really
want to use regexes, and I like the Perl-style &lt;code&gt;pcre-light&lt;/code&gt; family of
libraries that now includes &lt;code&gt;pcre-heavy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also, I showed how to add two lines to the top of a Haskell program to
turn it into a Stack script.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Haskell tidbits: 24 days of Hackage, 2015: day 1: Introduction and Stack</title>
      <link>http://conscientiousprogrammer.com/blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/</link>
      <pubDate>Mon, 30 Nov 2015 16:20:11 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:c37cfe20acfff0cff8579f026185f721&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Day 1: &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;Introduction and Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 2: &lt;a href=&#34;../../blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/&#34;&gt;Regexes with pcre-heavy; standalone Haskell scripts using Stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 3: &lt;a href=&#34;../../blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/&#34;&gt;HSpec; the importance of testing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 4:
&lt;a href=&#34;../../blog/2015/12/04/24-days-of-hackage-2015-day-4-wreq-web-client-programming-with-notes-on-lens-and-operator-syntax/&#34;&gt;wreq: Web client programming; with notes on lens and operator syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 5: &lt;a href=&#34;../../blog/2015/12/05/24-days-of-hackage-2015-day-5-should-not-typecheck-making-haskell-sort-of-dynamically-typed-with-deferred-type-errors/&#34;&gt;should-not-typecheck: making
Haskell sort of dynamically typed with deferred type errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Day 6: &lt;a href=&#34;../../blog/2015/12/06/24-days-of-hackage-2015-day-6-finding-utilities-with-hoogle-and-hayoo-missingh-extra/&#34;&gt;finding utilities with Hoogle
and Hayoo: MissingH, extra&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;day-1:c37cfe20acfff0cff8579f026185f721&#34;&gt;Day 1&lt;/h2&gt;

&lt;p&gt;A couple of days ago, I happened to see a
&lt;a href=&#34;https://twitter.com/acid2/status/669882628695281669&#34;&gt;tweet from Ollie Charles&lt;/a&gt;
that he didn&amp;rsquo;t have time to do his usual annual December &amp;ldquo;24 days of&amp;hellip;&amp;rdquo;
Haskell blog posts this year (2015) and felt sad because I&amp;rsquo;ve
learned a huge amount from
&lt;a href=&#34;https://ocharles.org.uk/blog/&#34;&gt;reading them&lt;/a&gt;. In both 2012 and 2013, he
wrote &amp;ldquo;24 days of Hackage&amp;rdquo;, daily short and sweet blog posts that
showed how to use selected Haskell packages you can get from the
community archive &lt;a href=&#34;http://hackage.haskell.org/&#34;&gt;Hackage&lt;/a&gt;, and in 2014
he covered GHC language extensions.&lt;/p&gt;

&lt;p&gt;With some trepidation, I decided that I would do a &amp;ldquo;24 days of
Hackage&amp;rdquo; series myself to cap off this year, to share a selection of
the huge number of Haskell packages I find useful. I thought it would
be particularly appropriate to do this given that 2015 was the year
that I migrated to &lt;em&gt;using Haskell as my main language&lt;/em&gt; for most new work and
personal projects, and therefore this has been a year of considerable
discovery for me.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:c37cfe20acfff0cff8579f026185f721&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series will be at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;my-selection-criteria:c37cfe20acfff0cff8579f026185f721&#34;&gt;My selection criteria&lt;/h2&gt;

&lt;p&gt;How to choose what to cover? I like what Ollie wrote in his
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-01-24-days-of-hackage.html&#34;&gt;2012 inaugural post&lt;/a&gt;:
&amp;ldquo;This will be a whirlwind tour of some modules that I use on an almost
daily basis, including modules that have inspired me, modules that
have changed the way I think about code, and some modules that are so
amazing I’m not even smart enough to use them!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;My own intention: some of what I&amp;rsquo;ll cover is already popular and
well-known, some may be just minor but useful utilities, some may be
completely obscure, but the underlying theme will be &amp;ldquo;stuff I use and
can briefly say something useful about&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;stack:c37cfe20acfff0cff8579f026185f721&#34;&gt;Stack&lt;/h2&gt;

&lt;p&gt;It was a no-brainer to choose the first day&amp;rsquo;s topic:
&lt;a href=&#34;http://haskellstack.org/&#34;&gt;Stack&lt;/a&gt;, the main new thing for Haskell in
2015 other than &lt;a href=&#34;https://www.haskell.org/ghc/&#34;&gt;GHC&lt;/a&gt; 7.10.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack changed my (Haskell) life.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Stack is a game changer for the Haskell community. It is an all-in-one
solution for creating Haskell projects, managing dependencies,
building, and more. Since Stack came out, I&amp;rsquo;ve been slowly migrating
old projects to use it, and I use Stack for all new projects,
including the
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;repo for this article series&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not giving a full-blown tutorial on Stack here today, just a
little taste, and you can read the
&lt;a href=&#34;http://haskellstack.org/&#34;&gt;official documentation&lt;/a&gt; for details, but
what I want to emphasize is that Stack is useful not only for
experienced developers, but especially also for newcomers, so part of
today&amp;rsquo;s article is geared specifically to newcomers (or those who
tried Haskell once and are interested in a fresh start with better
tooling).&lt;/p&gt;

&lt;h2 id=&#34;how-do-i-get-started-with-haskell:c37cfe20acfff0cff8579f026185f721&#34;&gt;&amp;ldquo;How do I get started with Haskell&amp;rdquo;?&lt;/h2&gt;

&lt;p&gt;When I launched &lt;a href=&#34;http://pittsburghhaskell.org/&#34;&gt;Pittsburgh Haskell&lt;/a&gt;
in February this year (2015), I faced a huge hurdle: helping newcomers
to Haskell get started. I created an introductory workshop session,
but a huge number of people were discouraged by my best shot at
creating &lt;a href=&#34;https://github.com/pittsburgh-haskell/haskell-installation&#34;&gt;a now-obsolete set of Haskell installation instructions&lt;/a&gt; that would work for Mac OS,
Windows, and Linux, and people had major problems installing a basic
tool chain, and versioning issues if they already had an old version
of GHC installed. Too much time was wasted on trying to help people with
installation.&lt;/p&gt;

&lt;p&gt;Pittsburgh Haskell happened to go on hiatus in April as I got busy
with many other things and there was no momentum at the time to keep
it going, but I believe one huge problem in trying to create a new
local Haskell community from newcomers was the tooling/setup
annoyance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Stack solves this problem.&lt;/strong&gt; If I gave an introductory Haskell workshop again, I would definitely use Stack.&lt;/p&gt;

&lt;h2 id=&#34;an-example-of-getting-started-with-stack-using-a-custom-template:c37cfe20acfff0cff8579f026185f721&#34;&gt;An example of getting started with Stack using a custom template&lt;/h2&gt;

&lt;p&gt;If you don&amp;rsquo;t already use Stack,
&lt;a href=&#34;http://docs.haskellstack.org/en/stable/README.html#how-to-install&#34;&gt;download it&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Stack Web site already has documentation on how to get started
with Stack using a default template. Here, I want to promote the idea
of using and sharing custom templates. This is not documented so well,
but I think will become more and more important for newcomers, and is
also of course useful for any of us who end up creating the same
boilerplate project setups.&lt;/p&gt;

&lt;h3 id=&#34;using-an-official-template:c37cfe20acfff0cff8579f026185f721&#34;&gt;Using an official template&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve created a custom template called &lt;code&gt;franklinchen&lt;/code&gt; that is part of
the official &lt;a href=&#34;https://github.com/commercialhaskell/stack-templates&#34;&gt;&lt;code&gt;stack-templates&lt;/code&gt;&lt;/a&gt;
repo.&lt;/p&gt;

&lt;p&gt;If you run&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack new stack-template-demo franklinchen
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;you will be prompted for information to create a new project called &lt;code&gt;stack-template-demo&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;using-your-own-local-template:c37cfe20acfff0cff8579f026185f721&#34;&gt;Using your own local template&lt;/h3&gt;

&lt;p&gt;Note that the template specified does &lt;em&gt;not&lt;/em&gt; have to be in the official
&lt;code&gt;stack-templates&lt;/code&gt; repo. It can also be on your local file system. For
example, before I submitted my template to &lt;code&gt;stack-templates&lt;/code&gt;, I used
to run&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack new stack-template-demo /path/on/my/computer/to/franklinchen.hsfiles
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;where &lt;code&gt;franklinchen.hsfiles&lt;/code&gt; is my template (read below on creating
your own template).&lt;/p&gt;

&lt;p&gt;(I&amp;rsquo;ve put up an instance of the generated project up
&lt;a href=&#34;https://github.com/FranklinChen/stack-template-demo&#34;&gt;on GitHub&lt;/a&gt; if
you want to look at its structure without installing and running Stack
right now.)&lt;/p&gt;

&lt;h3 id=&#34;getting-started-with-the-newly-generated-project:c37cfe20acfff0cff8579f026185f721&#34;&gt;Getting started with the newly generated project&lt;/h3&gt;

&lt;p&gt;Enter the project directory:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;cd &lt;/span&gt;stack-template-demo
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;stack-downloads-ghc-for-you:c37cfe20acfff0cff8579f026185f721&#34;&gt;Stack downloads GHC for you&lt;/h3&gt;

&lt;p&gt;Run&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack setup
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you do not already have an appropriate version of GHC installed,
Stack will &lt;em&gt;automatically&lt;/em&gt; download and install it for you, into an
area in Stack&amp;rsquo;s configuration directory &lt;code&gt;~/.stack/&lt;/code&gt;. The important
thing to note is that when using Stack, multiple versions of GHC can
coexist as desired for different build configurations and setups. This
feature is really important, because not everyone uses the same
version of GHC and you can build your project against multiple
versions of GHC easily.&lt;/p&gt;

&lt;p&gt;This automatic-downloading feature is particularly useful for
newcomers who don&amp;rsquo;t need to mess around with some kind of separate
global installation requiring special privileges.&lt;/p&gt;

&lt;p&gt;The output, if Stack needs to download anything:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;Preparing to install GHC to an isolated location.&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;This will not interfere with any system-level installation.&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Downloaded ghc-7.10.2.&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Installed GHC.&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;stack will use a locally installed GHC&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;For more information on paths, see &amp;#39;stack path&amp;#39; and &amp;#39;stack exec env&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;To use this GHC and packages outside of a project, consider using:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;stack ghc, stack ghci, stack runghc, or stack exec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;launching-the-ghci-repl:c37cfe20acfff0cff8579f026185f721&#34;&gt;Launching the GHCi REPL&lt;/h3&gt;

&lt;p&gt;The most important thing for a newcomer to Haskell is to get started
with the GHCi REPL, so let&amp;rsquo;s do that right away. Doing this within the
context of a project while preloading the modules of the project is
simple with Stack.&lt;/p&gt;

&lt;p&gt;Run&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack ghci
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note that &lt;strong&gt;only the first time&lt;/strong&gt; you do this (or other commands that
require getting library dependencies), Stack may take a while to
download and build them. The dependencies will actually end up being
installed and cached such that &lt;em&gt;other projects&lt;/em&gt; in the future that use
them can reuse them. This is a huge advantage of using Stack versus
the old days before Stack, when there was always an issue of
redownloading and recompiling the same libraries for different
projects; that was a tremendous time and space waster! Stack
intelligently figures out for you what can be shared consistently or
not.&lt;/p&gt;

&lt;p&gt;Stack launches a GHCi REPL with our modules preloaded:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;Ok, modules loaded: Lib, Main.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In &lt;code&gt;src/Lib.hs&lt;/code&gt; of the sample project, we have a silly module
illustrating some &lt;a href=&#34;https://www.haskell.org/haddock/&#34;&gt;Haddock&lt;/a&gt;
documentation comments:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | A library to do stuff.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Lib&lt;/span&gt;
    (
      &lt;span style=&#34;color: #0000FF&#34;&gt;ourAdd&lt;/span&gt;
    ) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Add two &amp;#39;Int&amp;#39; values.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;ourAdd&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ left&lt;/span&gt;
       &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ right&lt;/span&gt;
       &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ sum&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;ourAdd&lt;/span&gt; x y &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can access the &lt;code&gt;Lib&lt;/code&gt; module from the REPL:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; ourAdd 2 3&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;5&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; Lib.ourAdd 4 5&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can also access &lt;code&gt;Main&lt;/code&gt;, which is defined in &lt;code&gt;app/Main.hs&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Main&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Lib&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;ourAdd&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Printf&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;printf&lt;/span&gt;)

&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;2 + 3 = %d&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; (ourAdd &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; main&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;2 + 3 = 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;building-and-running-the-project:c37cfe20acfff0cff8579f026185f721&#34;&gt;Building and running the project&lt;/h3&gt;

&lt;p&gt;You could have explicitly compiled the project first, before launching
the REPL. In practice in real projects, I start by compiling a project
to get the dependencies compiled, before I use GHCi, but the above
does it for you too:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack build
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Because I defined a native-compiled binary executable named
&lt;code&gt;stack-template-demo&lt;/code&gt; in our Cabal file &lt;code&gt;stack-template-demo.cabal&lt;/code&gt;,
we can run the executable:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack &lt;span style=&#34;color: #008000&#34;&gt;exec &lt;/span&gt;stack-template-demo
&lt;span style=&#34;color: #888888&#34;&gt;2 + 3 = 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;I supplied unit tests for &lt;code&gt;Lib&lt;/code&gt; in &lt;code&gt;test/LibSpec.hs&lt;/code&gt; that can be run:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack &lt;span style=&#34;color: #008000&#34;&gt;test&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Lib&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;  Lib&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    works&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    ourAdd is commutative&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;Finished in 0.0007 seconds&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;2 examples, 0 failures&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;installing-the-library-and-executable:c37cfe20acfff0cff8579f026185f721&#34;&gt;Installing the library and executable&lt;/h3&gt;

&lt;p&gt;You can now install the library and executable for your own use later:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack install
&lt;span style=&#34;color: #888888&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Copying from /Users/chen/stack-template-demo/.stack-work/install/x86_64-osx/lts-3.16/7.10.2/bin/stack-template-demo to /Users/chen/.local/bin/stack-template-demo&lt;/span&gt;

&lt;span style=&#34;color: #888888&#34;&gt;Copied executables to /Users/chen/.local/bin:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;- stack-template-demo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;For example (since &lt;code&gt;~/.local/bin&lt;/code&gt; is in my &lt;code&gt;PATH&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; stack-template-demo
&lt;span style=&#34;color: #888888&#34;&gt;2 + 3 = 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;your-own-stack-template-configuration:c37cfe20acfff0cff8579f026185f721&#34;&gt;Your own Stack template configuration&lt;/h3&gt;

&lt;p&gt;When using Stack templates, it&amp;rsquo;s useful to set up a
configuration so that information can automatically be filled out for
you when you generate new projects. The documentation for
configuration is
&lt;a href=&#34;http://docs.haskellstack.org/en/stable/yaml_configuration.html&#34;&gt;here&lt;/a&gt;. Create
a file in
&lt;code&gt;~/.stack/config.yaml&lt;/code&gt;. Mine has:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;templates:
  params:
    author-email: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;franklinchen@franklinchen.com&amp;quot;&lt;/span&gt;
    author-name: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Franklin&lt;/span&gt;&lt;span style=&#34;color: #19177C&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;Chen&amp;quot;&lt;/span&gt;
    category: test
    copyright: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;2015&amp;quot;&lt;/span&gt;
    github-username: &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;FranklinChen&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;other-bells-and-whistles:c37cfe20acfff0cff8579f026185f721&#34;&gt;Other bells and whistles&lt;/h3&gt;

&lt;p&gt;I try to use &lt;a href=&#34;https://travis-ci.org/&#34;&gt;Travis CI&lt;/a&gt; for any public
code I put up, so my template generates a &lt;code&gt;.travis.yml&lt;/code&gt; file that uses
Stack. I&amp;rsquo;ve started to migrate my former Travis setups based on
&lt;a href=&#34;https://github.com/hvr/multi-ghc-travis&#34;&gt;&lt;code&gt;multi-ghc-travis&lt;/code&gt;&lt;/a&gt; to use
Stack instead.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-custom-stack-project-template:c37cfe20acfff0cff8579f026185f721&#34;&gt;Creating a custom Stack project template&lt;/h2&gt;

&lt;p&gt;It was surprising to me that how to create a custom template is not
covered in the main Stack documentation. Instead, I found it at the
&lt;a href=&#34;https://github.com/commercialhaskell/stack-templates&#34;&gt;&lt;code&gt;stack-templates&lt;/code&gt;&lt;/a&gt;
site.&lt;/p&gt;

&lt;p&gt;The method of creating a custom template is kind of clumsy, involving
creating a single file with embedded directives to indicate generated
file name and directory structure, but it&amp;rsquo;s a start.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:c37cfe20acfff0cff8579f026185f721&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For day 1 of my &amp;ldquo;24 days of Hackage, 2015&amp;rdquo;, I&amp;rsquo;ve briefly introduced
how to use Stack, the Haskell tool that I&amp;rsquo;m using to build and run all
the sample code for this article series.&lt;/p&gt;

&lt;p&gt;Next up: some real code!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>