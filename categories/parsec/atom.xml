<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parsec on The Conscientious Programmer</title>
    <link>http://ConscientiousProgrammer.com/categories/parsec/</link>
    <description>Recent content in Parsec on The Conscientious Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Dec 2015 08:00:00 -0500</lastBuildDate>
    <atom:link href="http://ConscientiousProgrammer.com/categories/parsec/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>24 days of Hackage, 2015: day 10: s-cargot: using S-expression syntax</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/10/24-days-of-hackage-2015-day-10-s-cargot-using-s-expression-syntax/</link>
      <pubDate>Thu, 10 Dec 2015 08:00:00 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/10/24-days-of-hackage-2015-day-10-s-cargot-using-s-expression-syntax/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-10:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Day 10&lt;/h2&gt;

&lt;p&gt;There are times when I&amp;rsquo;m jealous of the Lisp world.&lt;/p&gt;

&lt;p&gt;One of those times is when defining some domain-specific language,
because in the Lisp world, the natural thing to do is to represent it
using S-expressions as the concrete syntax, and not fuss with defining
yet another special syntax, along with writing a parser for that
syntax into the abstract syntax as well as a pretty-printer from the
abstract syntax back to the concrete syntax. Maybe in the long run
users might want a special syntax that is not just S-expressions, but
for quick initial prototyping, at least, it seems worthwhile to not
commit to any special syntax and just use S-expressions. Although
there is nothing magical about S-expressions (or XML or JSON or any
other generic representation of a tree data structure), they are
particularly concise and flexible.&lt;/p&gt;

&lt;p&gt;S-expressions are so useful that in my first job as a software
engineer in the 1990s, we actually had a C++ S-expression library for
input and output of a format that amounted to a domain-specific
language (this was before XML was invented) that was processed by many
tools (including a validator that I wrote in Standard ML).&lt;/p&gt;

&lt;p&gt;A library on Hackage for working with S-expressions in Haskell is
&lt;a href=&#34;http://hackage.haskell.org/package/s-cargot&#34;&gt;&lt;code&gt;s-cargot&lt;/code&gt;&lt;/a&gt;. There have
been many others, but most of them have gone sadly unmaintained,
whereas this one is new and comes with bells and whistles.&lt;/p&gt;

&lt;p&gt;Today I&amp;rsquo;ll give an example of how to use this library, in the context
of a problem domain in which having a concrete syntax is important.&lt;/p&gt;

&lt;h2 id=&#34;installation:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;We need to add &lt;code&gt;s-cargot&lt;/code&gt; to &lt;code&gt;stack.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;- s-cargot-0.1.0.0
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;the-task-symbolic-differentiation:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;The task: symbolic differentiation&lt;/h2&gt;

&lt;p&gt;The task we solve here is, appropriately enough, a translation from the Lisp
(Scheme, to be precise) code for a &lt;a href=&#34;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%_sec_2.3.2&#34;&gt;symbolic differentiator of
mathematical expressions&lt;/a&gt; in the classic computer science textbook
&lt;a href=&#34;https://mitpress.mit.edu/sicp/&#34;&gt;&amp;ldquo;Structure and Interpretation of Computer Programs&amp;rdquo;&lt;/a&gt;. I
won&amp;rsquo;t be walking through the solution here, but just focusing on some
syntax issues.&lt;/p&gt;

&lt;p&gt;Example: given a mathematical expression such as the linear function
&lt;code&gt;5x + 7&lt;/code&gt;, we want to find the symbolic derivative with respect to &lt;code&gt;x&lt;/code&gt;,
to get &lt;code&gt;5&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;simplest-syntax-for-the-expression-type:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Simplest syntax for the expression type&lt;/h2&gt;

&lt;p&gt;How do we model an expression and a function to compute a derivative
of an expression? Let&amp;rsquo;s start with the most vanilla possible way,
which is to define a data type for expression, &lt;code&gt;Exp&lt;/code&gt;, along with
ordinary alphanumeric constructors &lt;code&gt;N&lt;/code&gt; (for number), &lt;code&gt;V&lt;/code&gt; (for
variable), &lt;code&gt;Plus&lt;/code&gt; (for sum of subexpressions), &lt;code&gt;Times&lt;/code&gt; (for product of
subexpressions). A sample subset of an appropriate HSpec/QuickCheck
spec to define what we need:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaSyntaxSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaSyntax&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;), &lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;prop&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.QuickCheck&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;==&amp;gt;&lt;/span&gt;))

&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;symbolic differentiation&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x + n) == 1&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x n &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n)) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x + y) == x, if x /= y&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x y &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      x &lt;span style=&#34;color: #666666&#34;&gt;/=&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;==&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; y)) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; y
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (a * x + b) == x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;a x b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x)) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; b)) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x * y * (x + 3)) == (x * y) + y * (x + 3)&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;))
                   (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;))) &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; `shouldBe`
        (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;))
              (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;))))
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The syntax looks OK for simple expressions, but ugly when you have
lots of nested subexpressions, with parentheses for grouping, as in
the final artificial example.&lt;/p&gt;

&lt;p&gt;Here is the code for a still-naive symbolic differentiator, having
only a few heuristics built in for some simplification through
rewriting (for example, adding &lt;code&gt;0&lt;/code&gt; to an expression results in that
expression rather than construction of a superfluous &lt;code&gt;N 0&lt;/code&gt;
subexpression):&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaSyntax&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Variable in an expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ number&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt;          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ variable&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ sum&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ product&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Derivative of expression with respect to a variable.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;)         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; v&amp;#39;)        v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; v&amp;#39; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; v &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; e1 e2)  v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; plus (deriv e1 v) (deriv e2 v)
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; e1 e2) v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; plus (times e1 (deriv e2 v))
                             (times (deriv e1 v) e2)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)  e      &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; e      (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; e1     e2     &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; e1 e2

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;      &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;      (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)  e      &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; e      (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;)  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; e1     e2     &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; e1 e2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The syntax of the code, using pattern matching, looks reasonably good
to me. It&amp;rsquo;s the &lt;code&gt;Exp&lt;/code&gt; data construction that looks a bit ugly,
although not terrible. So we have a situation in which the implementor
of this little expression language is fairly happy, but the user is
not. In fact, we haven&amp;rsquo;t even provided a way for a user outside the
system to create expressions: right now, we have an API but no parser
from a string into an expression.&lt;/p&gt;

&lt;h2 id=&#34;parsing-from-what-format:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Parsing from what format?&lt;/h2&gt;

&lt;p&gt;One way to go is to write a custom parser from a custom syntax, for
example maybe write a function &lt;code&gt;fromString :: String -&amp;gt; Exp&lt;/code&gt; such that&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;fromString&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;5x + 7y + 20&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;))
             (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;)))
       (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;20&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;We would also want to write a pretty-printer &lt;code&gt;toString :: Exp -&amp;gt;
String&lt;/code&gt; such that maybe it&amp;rsquo;s smart enough to go&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;toString&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;))
                     (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;)))
               (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;20&lt;/span&gt;)) &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;5x + 7y + 20&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;It is straightforward to write such a parser using
&lt;a href=&#34;http://hackage.haskell.org/package/parsec&#34;&gt;&lt;code&gt;parsec&lt;/code&gt;&lt;/a&gt; or the
like, but you can imagine that sometimes it might be annoying to
design the syntax for a much more complex language (including special
infix operators, precedences, scoping keywords, different kinds of
braces, etc.) and also make users learn it.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s assume for the purpose of this article that we have a reason
to prefer prefix-only S-expressions, just as the Lisp community does
in order to avoid all the hassles of a custom syntax.&lt;/p&gt;

&lt;p&gt;Here are some sample QuickCheck tests to show what it is we want to be
able to do. (Note that for convenience, we are using string
interpolation through the
&lt;a href=&#34;http://hackage.haskell.org/package/here&#34;&gt;&lt;code&gt;here&lt;/code&gt;&lt;/a&gt; package as
introduced yesterday,
&lt;a href=&#34;../../blog/2015/12/09/24-days-of-hackage-2015-day-9-template-haskell-goodies-here-interpolate-file-embed/&#34;&gt;day 9&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE QuasiQuotes #-}&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.SExpSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaSyntax&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;))
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.SExp&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; SExp

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;prop&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.String.Here&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;i&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Required for auto-discovery.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;S-expression syntax for expression&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;(+ x a)&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color: #B00040&#34;&gt;SExp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;parse [i&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{a})&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;] `shouldBe`
        &lt;span style=&#34;color: #B00040&#34;&gt;Right&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a))

    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;(* (+ x a) (+ y b))&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;a b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color: #B00040&#34;&gt;SExp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;parse [i&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;
                     (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{a})
                        (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{b}))
                   &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;] `shouldBe`
        &lt;span style=&#34;color: #B00040&#34;&gt;Right&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a))
                     (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; b)))

    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;(!? x y)&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;
      &lt;span style=&#34;color: #B00040&#34;&gt;SExp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;parse &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;(!? x y)&amp;quot;&lt;/span&gt; `shouldBe`
        &lt;span style=&#34;color: #B00040&#34;&gt;Left&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;!?&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt; is not a valid operator&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve included a little test to indicate that we want some kind of
error handling also. Nothing is more annoying to a user than terrible
parse error messages. We won&amp;rsquo;t provide great messages here, but at
least will give an idea of how one could.&lt;/p&gt;

&lt;h2 id=&#34;the-s-expression-parser:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;The S-expression parser&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;s-cargot&lt;/code&gt; provides very flexible ways of constructing S-expression
parsers, based on what kind of syntax you want to allow (full Scheme
or not, for example), and allows hooks on many levels to support
readers as well as specifying the desired atom parser.&lt;/p&gt;

&lt;p&gt;Some imports first:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE QuasiQuotes #-}&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.SExp&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaSyntax&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;))

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.SCargot&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; S
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.SCargot.Language.Basic&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;basicParser&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.SCargot.Repr.WellFormed&lt;/span&gt;
       (&lt;span style=&#34;color: #B00040&#34;&gt;WellFormedSExpr&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;WFSList&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt;), &lt;span style=&#34;color: #0000FF&#34;&gt;fromWellFormed&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; Text
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text.Read&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;signed&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;decimal&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.String.Here&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;i&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Error when parsing.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The main driver is a pipeline of calling an &lt;code&gt;s-cargot&lt;/code&gt; parser and then
calling our own parser of an S-expression into our &lt;code&gt;Exp&lt;/code&gt; type:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | For simplicity, we use &amp;#39;basicParser&amp;#39; which just treats every atom&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- as &amp;#39;Text&amp;#39;, which we parse later rather than up front.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;parse&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Either&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;parse&lt;/span&gt; text &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; parseOneSexp text &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; toExp

&lt;span style=&#34;color: #0000FF&#34;&gt;parseOneSexp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Either&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;WellFormedSExpr&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;parseOneSexp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;decodeOne (&lt;span style=&#34;color: #B00040&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;asWellFormed basicParser)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Once we have a well-formed S-expression, we can pick it apart, while
catching errors if we encounter one.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;toExp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WellFormedSExpr&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Either&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;toExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; text) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; fromAtom text
&lt;span style=&#34;color: #0000FF&#34;&gt;toExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;WFSList&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; operatorText, sexp1, sexp2]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  operator &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; fromOperator operatorText
  e1 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; toExp sexp1
  e2 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; toExp sexp2
  return (operator e1 e2)
&lt;span style=&#34;color: #0000FF&#34;&gt;toExp&lt;/span&gt; list&lt;span style=&#34;color: #666666&#34;&gt;@&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;WFSList&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Left&lt;/span&gt; [i&lt;span style=&#34;color: #666666&#34;&gt;|$&lt;/span&gt;{list} should have exactly &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt; elements&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;]

&lt;span style=&#34;color: #0000FF&#34;&gt;fromOperator&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Either&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;fromOperator&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;+&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; return &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;fromOperator&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; return &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;fromOperator&lt;/span&gt; text &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Left&lt;/span&gt; [i&lt;span style=&#34;color: #666666&#34;&gt;|$&lt;/span&gt;{text} is not a valid operator&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;]

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Either an integer or a variable.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;fromAtom&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Either&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Error&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;fromAtom&lt;/span&gt; text &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;case&lt;/span&gt; signed decimal text &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;of&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;Right&lt;/span&gt; (n, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      return (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n)
    &lt;span style=&#34;color: #B00040&#34;&gt;Right&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color: #B00040&#34;&gt;Left&lt;/span&gt; [i&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;extra garbage after numeric &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{text}&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;]
    &lt;span style=&#34;color: #B00040&#34;&gt;Left&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      return (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;unpack text))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;pretty-printing:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Pretty-printing&lt;/h2&gt;

&lt;p&gt;And we get pretty-printing for free from &lt;code&gt;s-cargot&lt;/code&gt; if we turn our
&lt;code&gt;Exp&lt;/code&gt; into an S-expression first. I won&amp;rsquo;t show the details, but you
can use the basic S-expression printer or customize it with a lot
options including indentation strategy. Let&amp;rsquo;s just use the basic.&lt;/p&gt;

&lt;p&gt;A sample test for our &lt;code&gt;SExp.prettyPrint&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;pretty-printing&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;a b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color: #B00040&#34;&gt;SExp&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;prettyPrint (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a))
                              (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;) (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; b))) `shouldBe`
       [i&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{a}) (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt;{b}))&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The code:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;fromExp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WellFormedSExpr&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;fromExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;pack (show n))
&lt;span style=&#34;color: #0000FF&#34;&gt;fromExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;pack x)
&lt;span style=&#34;color: #0000FF&#34;&gt;fromExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; e1 e2) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WFSList&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;+&amp;quot;&lt;/span&gt;, fromExp e1, fromExp e2]
&lt;span style=&#34;color: #0000FF&#34;&gt;fromExp&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; e1 e2) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;WFSList&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;WFSAtom&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt;, fromExp e1, fromExp e2]

&lt;span style=&#34;color: #0000FF&#34;&gt;prettyPrint&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;prettyPrint&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;encodeOne (&lt;span style=&#34;color: #B00040&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;setFromCarrier fromWellFormed (&lt;span style=&#34;color: #B00040&#34;&gt;S&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;basicPrint id))
  &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; fromExp
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;summary-of-s-expression-parsing-and-pretty-printing:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Summary of S-expression parsing and pretty-printing&lt;/h2&gt;

&lt;p&gt;So there you have it: with a little bit of boilerplate you can get an
experience similar to that of working in Lisp. Note that with even
clever Template Haskell work with quasiquotation you could go further
than the pure text templates we&amp;rsquo;ve used for convenience, and create
pattern templates as well.&lt;/p&gt;

&lt;p&gt;We didn&amp;rsquo;t have to write a traditional parser, and we were able to
separate well-formedness from further processing. This is really
useful in many contexts: in my experience, the multi-level error
checking makes good error messages easier to create. Also, not
discussed here is how S-expressions can also help with prediction and
completion.&lt;/p&gt;

&lt;h2 id=&#34;optional-further-notes-on-syntax-for-domain-specific-languages:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Optional further notes on syntax for domain-specific languages&lt;/h2&gt;

&lt;p&gt;I wanted to point out that for some problem domains, such as this one
that happens to be mathematical, it is sometimes popular to make
things look mathematical. I&amp;rsquo;ve deliberately presented it without that
attempt first, but now I&amp;rsquo;ll show some syntactic variants.&lt;/p&gt;

&lt;h3 id=&#34;alphanumeric-identifiers-as-operators:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Alphanumeric identifiers as operators&lt;/h3&gt;

&lt;p&gt;First, one can use operator syntax with backticks and precedence
levels:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.AlphaOperatorSyntax&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Variable in an expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Precedences for our expression constructors.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt; `&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;`
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; `&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;`

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ number&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt;          &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ variable&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;   &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ sum&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ product&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Derivative of expression with respect to a variable.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;)         &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; v&amp;#39;)        v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; v&amp;#39; &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; v &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt; e1 e2)  v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; deriv e1 v `plus` deriv e2 v
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt; e1 e2) v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 `times` deriv e2 v
                        `plus`
                        deriv e1 v `times` e2

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Precedences for our expression &amp;quot;smart&amp;quot; constructors.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt; `plus`
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; `times`

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;plus&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  `plus` e    &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;e&lt;/span&gt;    `plus` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1 `plus` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;e1&lt;/span&gt;   `plus` e2   &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 `&lt;span style=&#34;color: #B00040&#34;&gt;Plus&lt;/span&gt;` e2

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;times&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  `times` &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;    &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;    `times` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;  `times` e    &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;e&lt;/span&gt;    `times` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1 `times` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;e1&lt;/span&gt;   `times` e2   &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 `&lt;span style=&#34;color: #B00040&#34;&gt;Times&lt;/span&gt;` e2
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Note that nothing has really changed, except the use of infix
function definitions and calls, and use of precedence to remove
parentheses, such as in the big expression for the derivative of a
product of expressions. But clarity is starting to be lost, for those
not already familiar with the problem domain and conventions.&lt;/p&gt;

&lt;h3 id=&#34;symbolic-identifiers-as-operators:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Symbolic identifiers as operators&lt;/h3&gt;

&lt;p&gt;One can go further and use symbolic identifiers in place of the
backticked alphanumeric operators. This is where many of us start
wondering what is going on:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;SymbolicDifferentiation.OperatorSyntax&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Variable in an expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Precedences for our expression constructors.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Expression.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ number&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt;        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ variable&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ sum&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ product&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Derivative of expression with respect to a variable.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Var&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;)       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x )      y &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; x &lt;span style=&#34;color: #666666&#34;&gt;==&lt;/span&gt; y &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (e1 &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; e2) v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; deriv e1 v &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt; deriv e2 v
&lt;span style=&#34;color: #0000FF&#34;&gt;deriv&lt;/span&gt; (e1 &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; e2) v &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; deriv e2 v
                      &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt;
                      deriv e1 v &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; e2

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Precedences for our expression &amp;quot;smart&amp;quot; constructors.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;infixl&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
(&lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt; e    &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;e&lt;/span&gt;    &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1 &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;e1&lt;/span&gt;   &lt;span style=&#34;color: #666666&#34;&gt;.+.&lt;/span&gt; e2   &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; e2

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Smart constructor that simplifies while combining subexpressions.&lt;/span&gt;
(&lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Exp&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt;  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;   &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;    &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; e    &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #0000FF&#34;&gt;e&lt;/span&gt;    &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e
&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n1 &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n2 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; (n1 &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; n2)
&lt;span style=&#34;color: #0000FF&#34;&gt;e1&lt;/span&gt;   &lt;span style=&#34;color: #666666&#34;&gt;.*.&lt;/span&gt; e2   &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; e1 &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; e2
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Depending on your taste, you might find that this funny syntax makes
the tests look nicer:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;symbolic differentiation&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x + n) == 1&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x n &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; n) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x + y) == x, if x /= y&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x y &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      x &lt;span style=&#34;color: #666666&#34;&gt;/=&lt;/span&gt; y &lt;span style=&#34;color: #666666&#34;&gt;==&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; y) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; y
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (a * x + b) == x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;a x b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; x &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; b) x `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; a
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d/dx (x * y * (x + 3)) == (x * y) + y * (x + 3)&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      deriv (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;)) &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; `shouldBe`
        (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt;) &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;y&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:*:&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;:+:&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;N&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;All this looks kind of cute if you&amp;rsquo;re used to it, but I think it can
look really weird otherwise; and I know that many non-Haskellers
seeing this before seeing the vanilla way get the wrong idea that you
have to write this way in Haskell and turn away in disgust and
confusion. This is why I showed the vanilla way first, and show this
only to illustrate that there are libraries out there that do try to
be very suggestive in symbolic operator usage, and also that there is
nothing special going on here: it&amp;rsquo;s just a different way of saying
exactly the same thing as the first version, with the second version
(backticked alphanumerics as operators) being a transitional step
toward this third version. It&amp;rsquo;s good to know about all three variants,
regardless of which one you prefer to read and write.&lt;/p&gt;

&lt;p&gt;But what about the S-expression route, which is to decouple the user
(represented by the tests) side of things from the abstract syntax and
the Haskell syntax? My intuition is that there are real benefits in at
least providing an alternate S-expression syntax for whatever other
concrete syntax is made available.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;S-expressions are a time-honored way of representing data. The
&lt;code&gt;s-cargot&lt;/code&gt; library comes with ways to build custom S-expression
parsers and pretty-printers and also comes with useful defaults.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:6004f4e5d78ba4d157aa1a919a6f7cf7&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 7: semigroups; NonEmpty list and a case study of types and tests</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/07/24-days-of-hackage-2015-day-7-semigroups-nonempty-list-and-a-case-study-of-types-and-tests/</link>
      <pubDate>Mon, 07 Dec 2015 08:00:00 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/07/24-days-of-hackage-2015-day-7-semigroups-nonempty-list-and-a-case-study-of-types-and-tests/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-7:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Day 7&lt;/h2&gt;

&lt;p&gt;How often has the following runtime error happened to you, whether in
Haskell or in some other language?&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*** Exception: Prelude.head: empty list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basically, code blew up that assumed a list was nonempty but it
wasn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;In fact,
&lt;a href=&#34;https://www.reddit.com/r/haskell/comments/3vlb8v/reading_data_problems/&#34;&gt;posted on Reddit recently&lt;/a&gt;
was a question about code that failed with&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;** Exception: Prelude.foldl1: empty list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;which is the same problem.&lt;/p&gt;

&lt;p&gt;Today, I present a case study: refactoring that code to take advantage
of an important data type that is going to be part of the Haskell
standard library, the &lt;code&gt;NonEmpty&lt;/code&gt; list type. This is part of Edward
Kmett&amp;rsquo;s &lt;a href=&#34;http://hackage.haskell.org/package/semigroups&#34;&gt;&lt;code&gt;semigroups&lt;/code&gt;&lt;/a&gt;
package that is
&lt;a href=&#34;https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid&#34;&gt;going into the standard library&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;in-general-should-we-adopt-defensive-or-confident-programming:958db8f82ca76230f48a5dece0db5e88&#34;&gt;In general, should we adopt defensive or confident programming?&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s easy to say, &amp;ldquo;well, we should program &lt;em&gt;defensively&lt;/em&gt; and not call
unsafe functions like &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;foldl1&lt;/code&gt; but should always check for an empty
list&amp;rdquo;. But what if we &lt;em&gt;know&lt;/em&gt; that the list is supposed to have at
least one element, perhaps because we validated that fact earlier on
in our data model. For example, say you are buying tickets for a
concert. You have to buy at least one, but could buy more than one. So
the business logic for the ticket pickup should always assume that
there is at least one ticket for you. It should not perpetually check
for emptiness because that should have been caught up front when you
ordered.&lt;/p&gt;

&lt;p&gt;The situation is exactly analogous to the problem of &lt;code&gt;NULL&lt;/code&gt; in many
languages: languages that use &lt;code&gt;NULL&lt;/code&gt; don&amp;rsquo;t distinguish at the &lt;em&gt;type&lt;/em&gt;
level between something that is &lt;em&gt;possibly-nonexistent&lt;/em&gt; (0 or 1
element) and something that is always there (1 element). It is
unfortunate when we know something about our data but aren&amp;rsquo;t saying it
in our type. In the case of lists, the situation is that a
&lt;em&gt;possibly-empty&lt;/em&gt; list can have 0 or more elements, while a nonempty
list can have 1 or more elements. Both situations are extremely common
(think of regex matching that distinguishes between &lt;code&gt;x*&lt;/code&gt; and &lt;code&gt;x+&lt;/code&gt;) and
should be modeled by different types!&lt;/p&gt;

&lt;p&gt;I believe that the real solution to this kind of problem is not to go
&lt;em&gt;defensive&lt;/em&gt; and litter all our code with random &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;isEmpty&lt;/code&gt;
kinds of runtime checks. The solution is also not to just go &amp;ldquo;cowboy
hacker&amp;rdquo; and invite possible and actual runtime exceptions by skipping
all checking.&lt;/p&gt;

&lt;p&gt;Instead, the solution, when practical, is to &lt;em&gt;use the right types&lt;/em&gt; so
that in the appropriate delimited scope of our code, runtime
exceptions &lt;em&gt;cannot possibly occur&lt;/em&gt; and therefore within that scope we
can program &lt;em&gt;confidently&lt;/em&gt; rather than &lt;em&gt;defensively&lt;/em&gt;. If we don&amp;rsquo;t use
our language&amp;rsquo;s type system to our advantage, we are just doing
ordinary dynamically typed programming in a typed language and missing
out on the full benefits of types. Since we made some sacrifices in
adopting a statically typed language instead of a dynamically typed
one, we should take advantage of what we got ourselves into. There&amp;rsquo;s
an interesting asymmetry in the programming world: it is &lt;em&gt;impossible&lt;/em&gt;
to write statically typed code in a dynamically typed language, but it
is &lt;em&gt;easy&lt;/em&gt; to write dynamically typed code in a statically typed
language!&lt;/p&gt;

&lt;h2 id=&#34;a-nonempty-list-type:958db8f82ca76230f48a5dece0db5e88&#34;&gt;A nonempty list type&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at the &lt;code&gt;NonEmpty&lt;/code&gt; list. You can already use it today before
it becomes part of the standard library, by just adding &lt;code&gt;semigroups&lt;/code&gt;
to your dependencies.&lt;/p&gt;

&lt;h3 id=&#34;what-are-the-requirements-for-a-nonempty-list:958db8f82ca76230f48a5dece0db5e88&#34;&gt;What are the requirements for a nonempty list?&lt;/h3&gt;

&lt;p&gt;Roughly, a &lt;code&gt;NonEmpty&lt;/code&gt; list should&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;support operations to interconvert with a regular possibly-empty list&lt;/li&gt;
&lt;li&gt;support analogues of standard list operations (like &lt;code&gt;map&lt;/code&gt; and
&lt;code&gt;filter&lt;/code&gt;) that carefully take into account whether the output is possibly-empty.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;quickcheck-for-specifying-laws-properties:958db8f82ca76230f48a5dece0db5e88&#34;&gt;QuickCheck for specifying laws (properties)&lt;/h3&gt;

&lt;p&gt;On
&lt;a href=&#34;../../blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/&#34;&gt;day 3&lt;/a&gt;,
I mentioned that QuickCheck is very useful for specifying requirements
when designing a new module. Ideally, when designing an API around a
new type, we treat it as an abstract data type and check the behavior
of operations on that type. The &lt;code&gt;NonEmpty&lt;/code&gt; list is simple enough that you
might think it&amp;rsquo;s overkill to do that, but I just wanted to present a
taste of what one might do up front if one were starting out with
property test-driven development. Let&amp;rsquo;s imagine we are creating a
module &lt;code&gt;Data.List.NonEmpty&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE ScopedTypeVariables #-}&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Part of a hypothetical test module for the semigroups package.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;HypotheticalSemigroupsSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; NonEmpty

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldSatisfy&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;prop&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.QuickCheck&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; QuickCheck
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Maybe&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; Maybe

&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;semigroups&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Data.List.NonEmpty&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;constructor NonEmpty.nonEmpty&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;fails on trying to construct from an empty regular list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
          &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;nonEmpty (&lt;span style=&#34;color: #B00040&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;]) `shouldBe` &lt;span style=&#34;color: #B00040&#34;&gt;Nothing&lt;/span&gt;
        prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;succeeds on any nonempty list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
          &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;QuickCheck&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; (xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;])) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;nonEmpty xs `shouldSatisfy` &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;isJust
      describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;conversion to regular list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;converts back to the original regular list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
          &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;QuickCheck&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; (xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;])) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; nonEmptyXs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;nonEmpty xs
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toList nonEmptyXs `shouldBe` xs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Basically, &lt;code&gt;nonEmpty&lt;/code&gt; is a safe constructor:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;nonEmpty&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; a)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is also an unsafe constructor called &lt;code&gt;fromList&lt;/code&gt;. I wouldn&amp;rsquo;t use
that except in case I really know that a list was not empty, because
it was returned from an API that guaranteed it but not in a typed
way. For example, I&amp;rsquo;ve faced this annoying problem when writing
parsers using libraries such as
&lt;a href=&#34;https://hackage.haskell.org/package/parsec&#34;&gt;&lt;code&gt;parsec&lt;/code&gt;&lt;/a&gt;, because
combinators such as &lt;code&gt;many1&lt;/code&gt; have a type&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;many1&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Stream&lt;/span&gt; s m t &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ParsecT&lt;/span&gt; s u m a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ParsecT&lt;/span&gt; s u m [a]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;even though the library &lt;em&gt;guarantees&lt;/em&gt; that if the parse succeeds, the
resulting list has at least one element! So in a situation like this,
I would feel justified in using the unsafe &lt;code&gt;NonEmpty.fromList&lt;/code&gt; to
&lt;em&gt;immediately&lt;/em&gt; unsafely wrap to get my known-to-be-nonempty-list into a
more refined type.&lt;/p&gt;

&lt;p&gt;A note on QuickCheck internals: &lt;code&gt;QuickCheck.NonEmpty&lt;/code&gt; (ignore the
coincidence of the token &lt;code&gt;NonEmpty&lt;/code&gt; in common with our module and type
in question!) is just a
&lt;a href=&#34;https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck.html#t:NonEmptyList&#34;&gt;newtype in QuickCheck&lt;/a&gt;
to generate regular lists &lt;code&gt;[a]&lt;/code&gt; that happen to be nonempty at runtime
(as in they are of the form &lt;code&gt;(x:xs)&lt;/code&gt;). Imagine if QuickCheck had been
written when the &lt;code&gt;NonEmpty&lt;/code&gt; type we want had existed. Then it could
just generate a real &lt;code&gt;NonEmpty&lt;/code&gt; rather than a fake newtype!&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t use QuickCheck or similar generative testing libraries,
check them out! These methods of testing are far more useful than the
example-based tests that I&amp;rsquo;ve provided so far in these articles just
for illustrative purposes. When possible, generative tests should be
written instead of manual example-based tests.&lt;/p&gt;

&lt;p&gt;(The use of &lt;code&gt;[Int]&lt;/code&gt; type annotations is because QuickCheck requires a
monomorphic type in order to generate concrete data to
test. &lt;code&gt;ScopedTypeVariables&lt;/code&gt; is a GHC extension that I wish were just
part of the standard Haskell language; it was &lt;a href=&#34;https://ocharles.org.uk/blog/guest-posts/2014-12-20-scoped-type-variables.html&#34;&gt;covered in a 2014 Day of
GHC Extensions&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&#34;a-few-notes-on-the-full-nonempty-api:958db8f82ca76230f48a5dece0db5e88&#34;&gt;A few notes on the full &lt;code&gt;NonEmpty&lt;/code&gt; API&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;map&lt;/code&gt; behaves as expected, because it doesn&amp;rsquo;t change the number of
elements and therefore mapping over a &lt;code&gt;NonEmpty&lt;/code&gt; is clearly a &lt;code&gt;NonEmpty&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;map&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; b
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, &lt;code&gt;filter&lt;/code&gt; on a &lt;code&gt;NonEmpty&lt;/code&gt; returns a regular possibly-empty
list, as it should, because the predicate can potentially fail on
every element:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;filter&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And &lt;code&gt;foldl1&lt;/code&gt;, unlike that of the regular list, is &lt;em&gt;safe&lt;/em&gt;. It cannot
fail, because it always starts off the reduction with the first
element as the seed.&lt;/p&gt;

&lt;p&gt;There are a whole bunch of other useful list functions.&lt;/p&gt;

&lt;p&gt;Oh, and the &lt;a href=&#34;http://hackage.haskell.org/package/semigroups-0.18.0.1/docs/src/Data-List-NonEmpty.html#NonEmpty&#34;&gt;internal implementation&lt;/a&gt; is what you might suspect: it&amp;rsquo;s
just a tuple of the first element with the possibly-empty tail, with a
special &amp;ldquo;cons&amp;rdquo; operator &lt;code&gt;:|&lt;/code&gt; that resembles the normal list&amp;rsquo;s &lt;code&gt;:&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color: #B00040&#34;&gt;:|&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;a-case-study-in-refactoring:958db8f82ca76230f48a5dece0db5e88&#34;&gt;A case study in refactoring&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at refactoring some
&lt;a href=&#34;https://www.reddit.com/r/haskell/comments/3vlb8v/reading_data_problems/&#34;&gt;code posted on Reddit&lt;/a&gt;
that was throwing an exception unexpectedly at run time.&lt;/p&gt;

&lt;p&gt;We won&amp;rsquo;t go into how the code might be written in a completely
different way, but just focus on identifying and removing unsafe code
that might throw exceptions.&lt;/p&gt;

&lt;p&gt;The code uses the excellent package
&lt;a href=&#34;http://hackage.haskell.org/package/split&#34;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; which I am a happy
user of. I have taken the liberty of adding comments to the code and
explicit imports for presentation here.&lt;/p&gt;

&lt;h3 id=&#34;original-unsafe-code:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Original unsafe code&lt;/h3&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.Split&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; Split

&lt;span style=&#34;color: #0000FF&#34;&gt;totalArea&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;totalArea&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;acc x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (acc &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; partialArea x)) &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; xs

&lt;span style=&#34;color: #0000FF&#34;&gt;partialArea&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;partialArea&lt;/span&gt; (l, w, h) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; (l&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;w &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; w&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;h &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; h&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;l) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; slack
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt; areas       &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [l, w, h]

        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- &amp;#39;maximum&amp;#39; is unsafe&lt;/span&gt;
        smallSides  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; filter (&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; maximum areas) areas

        &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- &amp;#39;foldl1&amp;#39; is unsafe&lt;/span&gt;
        slack       &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl1 (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;) smallSides

&lt;span style=&#34;color: #0000FF&#34;&gt;parseFile&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)]
&lt;span style=&#34;color: #0000FF&#34;&gt;parseFile&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; map (splitDimensions) (breakLines xs)

&lt;span style=&#34;color: #0000FF&#34;&gt;breakLines&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;]
&lt;span style=&#34;color: #0000FF&#34;&gt;breakLines&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Split&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;splitOn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | &amp;#39;read&amp;#39; is unsafe. &amp;#39;(!!)&amp;#39; is unsafe.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;splitDimensions&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;splitDimensions&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; (item &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, item &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, item &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
                   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt; item n &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; read ((&lt;span style=&#34;color: #B00040&#34;&gt;Split&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;splitOn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; xs)&lt;span style=&#34;color: #666666&#34;&gt;!!&lt;/span&gt;n)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This crashes on &lt;code&gt;foldl1&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;UnsafeListExample&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;totalArea crashes for a particular input&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; contents &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;1 x 1 x 1&amp;quot;&lt;/span&gt;
      evaluate (totalArea (parseFile contents)) `shouldThrow` anyException
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve already identified the problems above.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll ignore the fact that &lt;code&gt;read&lt;/code&gt; and list indexing &lt;code&gt;(!!)&lt;/code&gt; are unsafe,
because that&amp;rsquo;s not what is of interest here today.&lt;/p&gt;

&lt;p&gt;But &lt;code&gt;maximum&lt;/code&gt; and &lt;code&gt;foldl1&lt;/code&gt; are both unsafe on lists because they crash
on empty lists.&lt;/p&gt;

&lt;p&gt;It turns out &lt;em&gt;from manual inspection, acting as a human static
analyzer&lt;/em&gt; that the use of &lt;code&gt;maximum&lt;/code&gt; is OK here, because it&amp;rsquo;s operating
on a 3-element list &lt;code&gt;[l, w, h]&lt;/code&gt; created just before being passed to
&lt;code&gt;maximum&lt;/code&gt;. But this safety is not reflected in the types.&lt;/p&gt;

&lt;p&gt;How about &lt;code&gt;foldl1&lt;/code&gt;? If you carefully think about what &lt;code&gt;filter&lt;/code&gt;
returns, you can deduce that it might return an empty list, and if you
can&amp;rsquo;t guarantee that it&amp;rsquo;s nonempty, then the &lt;code&gt;foldl1&lt;/code&gt; will crash
hard. And it does.&lt;/p&gt;

&lt;p&gt;That was a lot of human thinking we had to do. Luckily, tests were run
that discovered the bug, but still, the code ended up posted to Reddit
asking what the bug was, so it&amp;rsquo;s not trivial to find these kinds of
lurking bugs. Is there a better way?&lt;/p&gt;

&lt;h3 id=&#34;refactoring-to-nonempty-lists:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Refactoring to &lt;code&gt;NonEmpty&lt;/code&gt; lists&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s use &lt;code&gt;NonEmpty&lt;/code&gt;. First of all, we change &lt;code&gt;totalArea&lt;/code&gt; to take a
&lt;code&gt;NonEmpty&lt;/code&gt; because that&amp;rsquo;s what we really want.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;totalArea&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;totalArea&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;acc x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (acc &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; partialArea x)) &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; xs
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Note that we only had to change the type of the parameter, not any of
the code, because &lt;code&gt;foldl&lt;/code&gt; has been implemented on &lt;code&gt;NonEmpty&lt;/code&gt; as well
as regular lists.&lt;/p&gt;

&lt;p&gt;Next, we change the body of &lt;code&gt;partialArea&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;partialArea&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;partialArea&lt;/span&gt; (l, w, h) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; (l&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;w &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; w&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;h &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; h&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;l) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; slack
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
    areas &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
    areas &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromList [l, w, h]

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- &amp;#39;maximum&amp;#39; is safe on &amp;#39;NonEmpty&amp;#39;&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- But &amp;#39;smallSides&amp;#39; can be empty because of &amp;#39;NonEmpty.filter&amp;#39;,&lt;/span&gt;
    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- and &amp;#39;NonEmpty.fromList&amp;#39; is unsafe!&lt;/span&gt;
    smallSides &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;]
    smallSides &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;filter (&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; maximum areas) areas

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- unsafe!&lt;/span&gt;
    smallSides1 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
    smallSides1 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromList smallSides

    &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- &amp;#39;foldl1&amp;#39; is safe on &amp;#39;NonEmpty&amp;#39;&lt;/span&gt;
    slack &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl1 (&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;) smallSides1
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;We made a number of changes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;since we&amp;rsquo;re creating a nonempty list, we turn it immediately into a
&lt;code&gt;NonEmpty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maximum&lt;/code&gt; is defined for &lt;code&gt;NonEmpty&lt;/code&gt; so we don&amp;rsquo;t have to change the
text of the code, but we know that &lt;code&gt;maximum&lt;/code&gt; is &lt;em&gt;guaranteed&lt;/em&gt; to be
safe for &lt;code&gt;NonEmpty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmpty.filter&lt;/code&gt;, as we discussed, returns a regular list, &lt;em&gt;not&lt;/em&gt; a
&lt;code&gt;NonEmpty&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;at the end, we want to safely compute &lt;code&gt;slack&lt;/code&gt;, but we can&amp;rsquo;t unless
we use a safe &lt;code&gt;foldl1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working backwards, we must convert a regular list to a &lt;code&gt;NonEmpty&lt;/code&gt;,
but there&amp;rsquo;s only one way to do that, and it&amp;rsquo;s unsafe!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So by refining the types used in the program, we have identified the
exact point at which &lt;em&gt;we could not write the necessary code&lt;/em&gt; without
resorting to &lt;code&gt;NonEmpty.fromList&lt;/code&gt;. So, strictly speaking, we haven&amp;rsquo;t
made a run time error turn into a compile time error, but we have
narrowed down what is going on purely mechanically by means of
following the types.&lt;/p&gt;

&lt;p&gt;The real problem in the code here seems to be that we wanted
&lt;code&gt;smallSides&lt;/code&gt; to be nonempty. The attempt to use only safe code
automatically resolved one possible source of unsafety (&lt;code&gt;maximum&lt;/code&gt;) and
pointed at a more complicated situation requiring a proof obligation
on the result of the &lt;code&gt;filter&lt;/code&gt;. &lt;code&gt;partialArea&lt;/code&gt; could be written to avoid
the proof obligation, by not using a list type at all for &lt;code&gt;areas&lt;/code&gt; to
perform the desired logic.&lt;/p&gt;

&lt;h3 id=&#34;maybe-the-real-problem-is-that-we-shouldn-t-use-lists-at-all-here:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Maybe the real problem is that we shouldn&amp;rsquo;t use lists at all here&lt;/h3&gt;

&lt;p&gt;You may have protested at this entire &lt;code&gt;NonEmpty&lt;/code&gt; exercise all this
time, because &lt;code&gt;NonEmpty&lt;/code&gt; is just the wrong type for all of this work!
&lt;strong&gt;There&amp;rsquo;s no point in trying to use some kind of fancy type that
doesn&amp;rsquo;t fit the problem.&lt;/strong&gt; There was no reason for the list
&lt;code&gt;[l, w, h]&lt;/code&gt; to be created at all. If you&amp;rsquo;re using a type and you still
run into proof obligations, often that means the type is not the right
one.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;partialArea&lt;/code&gt;, if we state the logic of what we really wanted (the
two smallest values out of three), then we can just write what we
mean:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Don&amp;#39;t use lists at all!&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;bestPartialArea&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;bestPartialArea&lt;/span&gt; (l, w, h) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; (l&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;w &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; w&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;h &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; h&lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;l) &lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; slack
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
    (side0, side1, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; sort3 (l, w, h)
    slack &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; side0 &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt; side1
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;where we created a utility module &lt;code&gt;Sort3&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Sort3&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;sort3&lt;/span&gt;) &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Sort exactly 3 values.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;sort3&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Ord&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a, a, a) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (a, a, a)
&lt;span style=&#34;color: #0000FF&#34;&gt;sort3&lt;/span&gt; (a0, a1, a2) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; a0 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; a1
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; a0 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; a2
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; a2 &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&lt;/span&gt; a1
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; (a2, a1, a0)
               &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; (a1, a2, a0)
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; (a1, a0, a2)
  &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; a1 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; a2
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; a0 &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; a2
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; (a2, a0, a1)
            &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; (a0, a2, a1)
       &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; (a0, a1, a2)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Yes, I did look on Hoogle (as recommended in my article yesterday on
searching for utility modules), and although I did not find this exact
function, I found the logic for it embedded in a context of optimal
sorting of vectors, in the
&lt;a href=&#34;https://hackage.haskell.org/package/vector-algorithms-0.7.0.1/docs/Data-Vector-Algorithms-Optimal.html&#34;&gt;&lt;code&gt;Data.Vector.Algorithms.Optimal&lt;/code&gt; module&lt;/a&gt;
of the
excellent
&lt;a href=&#34;https://hackage.haskell.org/package/vector-algorithms&#34;&gt;&lt;code&gt;vector-algorithms&lt;/code&gt; package&lt;/a&gt;
that I highly recommend when working with vectors. I copied and
pasted the logic in order to work on a simple triple.&lt;/p&gt;

&lt;h3 id=&#34;the-value-of-tests:958db8f82ca76230f48a5dece0db5e88&#34;&gt;The value of tests&lt;/h3&gt;

&lt;p&gt;QuickCheck is a great tool. Suppose we didn&amp;rsquo;t want to or couldn&amp;rsquo;t
refine the types in our code, for some reason. We can often still make of
testing to try to weed out easy-to-discover bugs. For example, we
could have written a sanity check test on &lt;code&gt;totalArea&lt;/code&gt; by generating a
whole bunch of random input and checking that the result is what we
expect, or at least something reasonable:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;UnsafeListExample&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;totalArea&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;parseFile&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldSatisfy&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldThrow&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;anyException&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;prop&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Positive&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;..&lt;/span&gt;))
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Exception&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;evaluate&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Printf&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;printf&lt;/span&gt;)

&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;UnsafeListExample&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;totalArea crashes for a particular input&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; contents &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;1 x 1 x 1&amp;quot;&lt;/span&gt;
      evaluate (totalArea (parseFile contents)) `shouldThrow` anyException
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;totalArea gives something reasonable on any triple of ints&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;(&lt;span style=&#34;color: #B00040&#34;&gt;Positive&lt;/span&gt; (l &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)) (&lt;span style=&#34;color: #B00040&#34;&gt;Positive&lt;/span&gt; (w &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)) (&lt;span style=&#34;color: #B00040&#34;&gt;Positive&lt;/span&gt; (h &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; contents &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;%d x %d x %d&amp;quot;&lt;/span&gt; l w h
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;in&lt;/span&gt; totalArea (parseFile contents) `shouldSatisfy` (&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Very quickly we get a counterexample reported by QuickCheck:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;  1) UnsafeListExample totalArea does not crash on any triple of ints&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       uncaught exception: ErrorCall (Prelude.foldl1: empty list) (after 4 tests)&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       Positive {getPositive = 2}&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       Positive {getPositive = 2}&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;       Positive {getPositive = 2}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Also, you may have wondered about that complicated optimal sort of 3
values. Did I copy and paste the logic correctly? For peace of mind, I
wrote a QuickCheck test for it:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Sort3&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;sort3 sorts correctly&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;(triple &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; (a0&amp;#39;, a1&amp;#39;, a2&amp;#39;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Sort3&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;sort3 triple
        &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;in&lt;/span&gt; a0&amp;#39; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;=&lt;/span&gt; a1&amp;#39; &lt;span style=&#34;color: #666666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; a1&amp;#39; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;=&lt;/span&gt; a2&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;I love QuickCheck. What would life be without it?&lt;/p&gt;

&lt;h3 id=&#34;some-bonus-refactorings:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Some bonus refactorings&lt;/h3&gt;

&lt;p&gt;Some other type-oriented refactorings into &lt;code&gt;NonEmpty&lt;/code&gt; as much as
possible that I won&amp;rsquo;t discuss in detail because they were mostly
irrelevant here:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;parseFile&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Char&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;parseFile&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;map (splitDimensions) (breakLines xs)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | We ended up not needing the fact that the input is nonempty, and&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- converted it to a regular list.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;breakLines&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Char&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;breakLines&lt;/span&gt; string1 &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; ourSplitOn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toList string1)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | &amp;#39;read&amp;#39; is unsafe. &amp;#39;(!!)&amp;#39; is unsafe.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;splitDimensions&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;)
&lt;span style=&#34;color: #0000FF&#34;&gt;splitDimensions&lt;/span&gt; xs &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; (item &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, item &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, item &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;)
                   &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt; item n &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; read ((&lt;span style=&#34;color: #B00040&#34;&gt;Split&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;splitOn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;x&amp;quot;&lt;/span&gt; xs)&lt;span style=&#34;color: #666666&#34;&gt;!!&lt;/span&gt;n)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Using unsafe &amp;#39;NonEmpty.fromList&amp;#39; is safe because we know&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- the result &amp;#39;from Split.splitOn&amp;#39; is nonempty. Note that the elements&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- themselves can be empty.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;ourSplitOn&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt; [a]
&lt;span style=&#34;color: #0000FF&#34;&gt;ourSplitOn&lt;/span&gt; subList list &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;NonEmpty&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromList (&lt;span style=&#34;color: #B00040&#34;&gt;Split&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;splitOn subList list)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;The most interesting thing was a tangential observation that
&lt;code&gt;Split.splitOn&lt;/code&gt; always returns a nonempty list of lists. So in
principle we could wrap the result into a &lt;code&gt;NonEmpty&lt;/code&gt;. I even wrote a
little passing QuickCheck test:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;split&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;splitOn always results in nonempty list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;subList (list &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span style=&#34;color: #B00040&#34;&gt;Split&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;splitOn subList list `shouldSatisfy` not &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; null
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Note: &lt;code&gt;split&lt;/code&gt; already has a &lt;a href=&#34;http://hub.darcs.net/byorgey/split/browse/test/&#34;&gt;huge set of property tests for its own
purposes&lt;/a&gt;. I love the
&lt;code&gt;split&lt;/code&gt; library. I think it&amp;rsquo;s been very well-tested. Check it out.&lt;/p&gt;

&lt;h2 id=&#34;a-brief-note-on-semigroups-semigroup-http-hackage-haskell-org-package-semigroups-0-18-0-1-docs-data-semigroup-html:958db8f82ca76230f48a5dece0db5e88&#34;&gt;A brief note on semigroups &lt;a href=&#34;http://hackage.haskell.org/package/semigroups-0.18.0.1/docs/Data-Semigroup.html&#34;&gt;&lt;code&gt;Semigroup&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;Semigroup&lt;/code&gt; is a type class representing an algebraic structure
requiring a single associative operation to be defined on it,
&amp;ldquo;append&amp;rdquo;, which in this library is provided as an operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Semigroup&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;A QuickCheck test verifying what we already know, which is that
&lt;code&gt;String&lt;/code&gt; has a &lt;code&gt;Semigroup&lt;/code&gt; instance, string append, and is associative as required:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;Data.Semigroup.Semigroup&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      prop &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&amp;lt;&amp;gt; is associative for String&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
        &lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;(x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;) y z &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; y) &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z `shouldBe` x &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; (y &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; z)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;You may already use this operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; in
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html&#34;&gt;&lt;code&gt;Monoid&lt;/code&gt;, which is already in the standard library&lt;/a&gt;,
but the &lt;code&gt;Monoid&lt;/code&gt; type class should really be a subclass of &lt;code&gt;Semigroup&lt;/code&gt;
and that&amp;rsquo;s what&amp;rsquo;s going to happen in a future version of Haskell
(conceptually, it should have been there all along, but Haskell was
invented 25 years ago in 1990 and &lt;code&gt;Semigroup&lt;/code&gt; was apparently not
considered important enough to put into the type class hierarchy then). The difference is that a &lt;code&gt;Monoid&lt;/code&gt; also requires
an identity element &lt;code&gt;mempty&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no space here to say anything about why semigroups and monoids
are useful in computing. Monoids in particular have become an everyday
word in Big Data circles because of MapReduce, which based on monoids for performance.&lt;/p&gt;

&lt;p&gt;A few Haskell oriented resources on monoids to check out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/Haskell/Monoids&#34;&gt;On Wikibooks&lt;/a&gt;
(The &lt;a href=&#34;https://en.wikibooks.org/wiki/Haskell&#34;&gt;Haskell Wikibook&lt;/a&gt; is a great resource for Haskell in general)&lt;/li&gt;
&lt;li&gt;A really nice article with code &lt;a href=&#34;https://izbicki.me/blog/gausian-distributions-are-monoids&#34;&gt;&amp;ldquo;Gaussian distributions are monoids&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion:958db8f82ca76230f48a5dece0db5e88&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The main takeaways today: consider using &lt;code&gt;NonEmpty&lt;/code&gt; when you have a
list that you know is not empty, so that you can confidently perform
operations on it without throwing an exception.  It&amp;rsquo;s just one
additional Cabal dependency away! Also make sure that you actually
wanted a list, and not a tuple or fixed-size vector or something like
that. And use QuickCheck.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:958db8f82ca76230f48a5dece0db5e88&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>24 days of Hackage, 2015: day 2: Regexes with pcre-heavy; standalone Haskell scripts using Stack</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/</link>
      <pubDate>Wed, 02 Dec 2015 07:50:12 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/02/24-days-of-hackage-2015-day-2-regexes-with-pcre-heavy-standalone-haskell-scripts-using-stack/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-2:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Day 2&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t laugh, but once upon a time, I made Perl my main programming
language of choice (between around 1999 and 2010). There were many
reasons for this, but one reason was that Perl made it very easy to do
text processing using regexes.&lt;/p&gt;

&lt;p&gt;If you are a seasoned Haskeller, you might be thinking, &amp;ldquo;Why not use a
real parser instead?&amp;ldquo;, such as the venerable
&lt;a href=&#34;https://hackage.haskell.org/package/parsec&#34;&gt;parsec&lt;/a&gt;, which was covered in a
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-10-24-days-of-hackage-parsec.html&#34;&gt;2012 day of Hackage&lt;/a&gt;?
(Or, today, one could consider one of several other newer alternative libraries
for parsing. A later day of Hackage will say more about this!)&lt;/p&gt;

&lt;p&gt;After all, Jamie Zawinski famously once wrote, &lt;em&gt;&amp;ldquo;Some people, when
confronted with a problem, think &amp;lsquo;I know, I&amp;rsquo;ll use regular
expressions.&amp;rsquo;  Now they have two problems.&amp;rdquo;&lt;/em&gt; I even gave a talk at
&lt;a href=&#34;http://pghtechfest.com/&#34;&gt;Pittsburgh Tech Fest&lt;/a&gt; in 2013,
&lt;a href=&#34;http://www.slideshare.net/FranklinChen/handout-22302440&#34;&gt;&amp;ldquo;Stop overusing regular expressions!&amp;rdquo;&lt;/a&gt;,
in which I promoted writing parsers rather than writing regexes.&lt;/p&gt;

&lt;p&gt;But, sometimes I do want to use a regex. In that case, I have been
using an obscure but useful package, &lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today I&amp;rsquo;ll show how to use &lt;code&gt;pcre-heavy&lt;/code&gt;, and while at it, also show
how to ship &lt;em&gt;one-file standalone Haskell scripts&lt;/em&gt; that only require
Stack.&lt;/p&gt;

&lt;h2 id=&#34;why-use-regexes-at-all:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Why use regexes at all?&lt;/h2&gt;

&lt;p&gt;Before going into &lt;code&gt;pcre-heavy&lt;/code&gt;, I thought I should explain when I use
regexes.&lt;/p&gt;

&lt;p&gt;Back when I was doing a lot of text extraction, cleaning, including
&lt;em&gt;correction&lt;/em&gt;, restructuring of messy data, regexes seemed the only
choice really. I had to not lose any &amp;ldquo;intended&amp;rdquo; information even if it
was obscured by garbage or misspellings or the like. I therefore could
not use some kind of approximate statistical technique, but had to
iteratively do do a lot exploratory work with some interactive
prompting in order to gradually clean up the data. Super-powerful
regex constructs of the Perl variety seemed perfect for this task.&lt;/p&gt;

&lt;p&gt;But even outside of such use cases, there&amp;rsquo;s no hiding from the fact
that regexes can be very convenient for simple tasks. Also,
because regexes are used so much in our programming world in general,
if we are migrating to Haskell some already-working regexes from
already-written code in some other language, it&amp;rsquo;s convenient to just
stick with regexes.&lt;/p&gt;

&lt;h2 id=&#34;which-haskell-regex-library-to-use:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Which Haskell regex library to use?!&lt;/h2&gt;

&lt;p&gt;A newcomer to Haskell must be overwhelmed by the lack of a single
standard library and syntax for regexes. I mean, take a look at this
&lt;a href=&#34;https://wiki.haskell.org/Regular_expressions&#34;&gt;wiki page&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Today, I&amp;rsquo;m presenting
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;, a
regex library that I&amp;rsquo;ve been using when I want regexes at all (I try
not to want them). It&amp;rsquo;s pretty new and not even mentioned on that wiki
page.&lt;/p&gt;

&lt;p&gt;Some of my criteria for choosing a regex library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I want Perl-style regexes. That&amp;rsquo;s what I&amp;rsquo;m used to and are a kind of
standard across regex support in many programming languages.&lt;/li&gt;
&lt;li&gt;Nice syntax is a plus. One of the selling points of using regexes is
that the conciseness of writing patterns, binding matches,
etc. Without such conciseness, I just think &amp;ldquo;Why not just write a
real parser? It only takes a couple of lines in Haskell anyway.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;High performance is a perfectly legitimate reason to use regexes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given these criteria, using a &lt;a href=&#34;http://www.pcre.org/&#34;&gt;PCRE&lt;/a&gt;-based
library seemed the way to go. OK, the wiki page lists a bunch of
PCRE-based libraries.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hackage.haskell.org/package/pcre-light&#34;&gt;&lt;code&gt;pcre-light&lt;/code&gt;&lt;/a&gt; is a
good way to go.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;It does require installation of the C library for
PCRE.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m mainly on Mac OS X, so I have PCRE installed through
Homebrew with &lt;code&gt;$ brew install pcre&lt;/code&gt;. I have PCRE working on
Linux. Unfortunately, I don&amp;rsquo;t use Windows, so if someone can verify
that &lt;code&gt;pcre-light&lt;/code&gt; installs OK on Windows, that would be great. I would
feel sad if I picked a library that is problematic for Windows users.&lt;/p&gt;

&lt;p&gt;Recently, out came
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;&lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/a&gt;, a
wrapper around &lt;code&gt;pcre-light&lt;/code&gt; that uses
&lt;a href=&#34;https://wiki.haskell.org/Template_Haskell&#34;&gt;Template Haskell&lt;/a&gt;, the GHC
extension that is &amp;ldquo;macros for Haskell&amp;rdquo;, enabling compile-time
metaprogramming (see the
&lt;a href=&#34;https://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html&#34;&gt;2014 Day of Hackage article about Template Haskell&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I liked it, so I use it.&lt;/p&gt;

&lt;h2 id=&#34;example-program-using-pcre-heavy:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Example program using &lt;code&gt;pcre-heavy&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;pcre-heavy&lt;/code&gt; has decent documentation on
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy&#34;&gt;its Hackage page&lt;/a&gt;, so
I recommend reading that for the full details on how to use it. I&amp;rsquo;ll
give just a simple example here in the context of a complete program
that does something.&lt;/p&gt;

&lt;h3 id=&#34;specification-and-some-test-cases:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Specification and some test cases&lt;/h3&gt;

&lt;p&gt;Say we have a file of lines of text that are supposed to have a
comma-separated format of&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a fixed header&lt;/li&gt;
&lt;li&gt;a text transcript&amp;rsquo;s file path&lt;/li&gt;
&lt;li&gt;an &amp;ldquo;audio&amp;rdquo; or &amp;ldquo;video&amp;rdquo; field indicating the type of associated media&lt;/li&gt;
&lt;li&gt;an optional annotation about whether the associated media is missing
or not yet linked into the transcript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(I made up this example based on the structured text specification
called CHAT that happens to include a single line of this format,
e.g. &lt;a href=&#34;http://talkbank.org/data-orig/Meeting/SCOTUS/2008/08-205.cha&#34;&gt;this coded Supreme Court oral argument transcript for &amp;ldquo;Citizens United v. Federal Election Commission&amp;rdquo;&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Examples that should match:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;@Media:	has-audio,   audio
@Media:	has-video,video
@Media:	has-audio-but-missing, audio, missing
@Media:	has-video-but-unlinked  , video,      unlinked
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Examples that should fail to match:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;@Media:	no-audio-or-video
@Media:	missing-media-field, unlinked
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;creating-a-regex:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Creating a regex&lt;/h3&gt;

&lt;p&gt;Here is a &lt;code&gt;pcre-heavy&lt;/code&gt; regex, using the
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#v:re&#34;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt;
Template Haskell
&lt;a href=&#34;https://wiki.haskell.org/Template_Haskell#QuasiQuoters&#34;&gt;quasiquoter&lt;/a&gt;
that builds a PCRE-compiled
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#t:Regex&#34;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [re&lt;span style=&#34;color: #666666&#34;&gt;|^@&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Media:\&lt;/span&gt;t([&lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ,]&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;)&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(audio&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;video)(&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;?:&lt;/span&gt;missing&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;unlinked))&lt;span style=&#34;color: #666666&#34;&gt;?|&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;regex-string-validated-at-haskell-compile-time:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Regex string validated at Haskell compile-time&lt;/h2&gt;

&lt;p&gt;One selling point of &lt;code&gt;pcre-heavy&lt;/code&gt; for me is that because it uses
Template Haskell, a bad regex string results in a Haskell-level
compile-time error rather than a runtime error.&lt;/p&gt;

&lt;p&gt;Example of a compile-time error:&lt;/p&gt;



&lt;p&gt;Loading this in GHCi or compiling with GHC results in&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;    Exception when trying to run compile-time code:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      Text.Regex.PCRE.Light: Error in regex: missing )&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    Code: template-haskell-2.10.0.0:Language.Haskell.TH.Quote.quoteExp&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;            re&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;            &amp;quot;^@Media:\\t([^ ,]+)\\ *,\\ *(audio|video)(\\ *,\\ *(?:missing|unlinked)?&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;using-the-regex:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Using the regex&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll use
&lt;a href=&#34;https://hackage.haskell.org/package/pcre-heavy-1.0.0.1/docs/Text-Regex-PCRE-Heavy.html#v:scan&#34;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;
to extract the matches (if any) against our regex on a string.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;scan&lt;/code&gt; returns a lazy list of all possible matches:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Simplified type signature for our purposes.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;scan&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [(&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;])]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Each match is a pair &lt;code&gt;(String, [String])&lt;/code&gt;, where the first component
is the whole string that matched, and the second is an ordered list of
parenthesized groupings in the regex. In our regex, we had three
parenthesized groupings, so a match could result in a three-element
grouping list:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; scan mediaRegex &amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;[(&amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;,[&amp;quot;foo&amp;quot;,&amp;quot;audio&amp;quot;,&amp;quot;, unlinked&amp;quot;])]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Since we only want
the first match (if any), we can just compose it with
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Maybe.html#v:listToMaybe&#34;&gt;&lt;code&gt;listToMaybe&lt;/code&gt; from &lt;code&gt;Data.Maybe&lt;/code&gt;&lt;/a&gt;,
which has type&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;listToMaybe&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;so &lt;code&gt;listToMaybe . scan mediaRegex&lt;/code&gt; has type &lt;code&gt;String -&amp;gt; Maybe (String, [String])&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;*Main&amp;gt; (listToMaybe . scan mediaRegex) &amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;Just (&amp;quot;@Media:\tfoo, audio, unlinked&amp;quot;,[&amp;quot;foo&amp;quot;,&amp;quot;audio&amp;quot;,&amp;quot;, unlinked&amp;quot;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;extracting-useful-information:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Extracting useful information&lt;/h2&gt;

&lt;p&gt;Finally, what we really wanted to do after matching is apply
additional business logic and get stuff into a real type as soon as
possible, rather than engage in &amp;ldquo;stringly-typed&amp;rdquo; programming and
context-dependent list lengths.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that for our task, we only care about matched lines that are
&lt;em&gt;not&lt;/em&gt; missing or unlinked, and skip those that are missing or
unlinked. We define a data type and use pattern matching to get out of
the untyped world into the typed world of our data model.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Extract information about a media file if it is present.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&#34;presentation-as-a-report:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Presentation as a report&lt;/h2&gt;

&lt;p&gt;Finally, now that we are done with the regex world, and have a data
model, all that is left is a driver to complete an example
command-line program.&lt;/p&gt;

&lt;p&gt;We have all the information needed to print out a report for each line.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Output a report.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Nothing&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match, but missing or unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And the final driver, piping everything through from standard input:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  s &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getContents
  mapM_ (reportOnInfo
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; fmap extractIfPresent
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; listToMaybe
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; scan mediaRegex
       ) (lines s)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;using-stack-to-ship-standalone-scripts:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Using Stack to ship standalone scripts&lt;/h2&gt;

&lt;p&gt;We can try our program from within the GHCi REPL by just typing &lt;code&gt;main&lt;/code&gt;
or &lt;code&gt;:main&lt;/code&gt; at the REPL prompt and typing in lines of text. We can also
do &lt;code&gt;stack build&lt;/code&gt; to native-compile into a shippable binary.&lt;/p&gt;

&lt;p&gt;But another option is to ship the source code as a standalone one-file
script. This can be very convenient in some circumstances, when you
can rely on the recipient simply installing Stack.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how we can turn our program into such a standalone script: just
add the following two lines and make the file executable:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;#!/&lt;/span&gt;usr&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;bin&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;env stack
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- stack --resolver lts-3.17 --install-ghc runghc --package pcre-heavy&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Stack will read the embedded command in order to install GHC, if
 needed, and first download and install the packages listed (here
 &lt;code&gt;pcre-heavy&lt;/code&gt;), if needed. We have pinned down the exact version of
 LTS in order to guarantee what versions of everything will be used by
 Stack. (Note: in this case, because of FFI with a
 C library, the recipient has to install PCRE first.)&lt;/p&gt;

&lt;p&gt;So if you have short programs that don&amp;rsquo;t need to be organized into
full-scale Cabal projects, you can treat Haskell as a &amp;ldquo;scripting
language&amp;rdquo; with full access to the libraries of Hackage!&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;$&lt;/span&gt; app/PCREHeavyExampleMain.hs &amp;lt; input.txt &amp;gt; output.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;a-warning:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;A warning&lt;/h3&gt;

&lt;p&gt;Although this Stack-as-Haskell-interpreter feature is kind of cool, I
prefer to write modular, separately testable libraries, while having
the &lt;code&gt;main&lt;/code&gt; driver of the &lt;code&gt;Main&lt;/code&gt; module of a program just use library
modules that do most of the real work. Furthermore, I prefer to build
and use native-compiled libraries and binaries because they&amp;rsquo;re just
much faster to start up and also run: &lt;code&gt;runghc&lt;/code&gt; is a Haskell
interpreter rather than a native optimizing compiler. But the beauty
of the GHC Haskell world is you can run in either mode, and flip from
one to the other seamlessly.&lt;/p&gt;

&lt;h3 id=&#34;here-s-our-complete-example-standalone-program:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Here&amp;rsquo;s our complete example standalone program&lt;/h3&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #666666&#34;&gt;#!/&lt;/span&gt;usr&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;bin&lt;span style=&#34;color: #666666&#34;&gt;/&lt;/span&gt;env stack
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- stack --resolver lts-3.17 --install-ghc runghc --package pcre-heavy&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE QuasiQuotes #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Main&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Regex.PCRE.Heavy&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;re&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;scan&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Maybe&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;listToMaybe&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Text.Printf&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;printf&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Match a media name, audio/video, and optional missing/unlinked.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Regex&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mediaRegex&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; [re&lt;span style=&#34;color: #666666&#34;&gt;|^@&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Media:\&lt;/span&gt;t([&lt;span style=&#34;color: #666666&#34;&gt;^&lt;/span&gt; ,]&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt;)&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(audio&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;video)(&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;,&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;?:&lt;/span&gt;missing&lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt;unlinked))&lt;span style=&#34;color: #666666&#34;&gt;?|&lt;/span&gt;]

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
    &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;FilePath&lt;/span&gt;
    &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;deriving&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;Show&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Extract information about a media file if it is present.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;, [&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, [name, &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video&amp;quot;&lt;/span&gt;]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; name
&lt;span style=&#34;color: #0000FF&#34;&gt;extractIfPresent&lt;/span&gt; (&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;_&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Output a report.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Maybe&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Info&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Nothing&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;no match&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Skip&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; putStrLn &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;match, but missing or unlinked&amp;quot;&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Audio&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;audio at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path
&lt;span style=&#34;color: #0000FF&#34;&gt;reportOnInfo&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Just&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Video&lt;/span&gt; path)) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; printf &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;video at %s&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt; path

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Driver, in traditional right-to-left syntax.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;IO&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;()&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;main&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
  s &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;&amp;lt;-&lt;/span&gt; getContents
  mapM_ (reportOnInfo
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; fmap extractIfPresent
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; listToMaybe
        &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; scan mediaRegex
       ) (lines s)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;some-additional-notes:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Some additional notes&lt;/h2&gt;

&lt;p&gt;One limitation faced by a short expository article with example code
is that we don&amp;rsquo;t like to waste space and attention, and therefore tend
to present quick-and-dirty code, rather than production-level code
(which is efficient, has sensible error recovery, well-commented). I&amp;rsquo;ve
been thinking about the dilemma of &lt;em&gt;how not to give the
wrong impression and set a bad example by showing simplistic example
code&lt;/em&gt;. There&amp;rsquo;s no easy answer, but I felt it might be useful to
provide optional &amp;ldquo;advanced&amp;rdquo; notes sometimes, on how to write real code.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pcre-heavy&lt;/code&gt; allows matching not only of &lt;code&gt;String&lt;/code&gt;, but also of
&lt;code&gt;ByteString&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; types. In practice, for efficiency, we
want to use
&lt;a href=&#34;http://hackage.haskell.org/package/bytestring&#34;&gt;&lt;code&gt;bytestring&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;http://hackage.haskell.org/package/text&#34;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt; as much as possible,
rather than the inefficient &lt;code&gt;String&lt;/code&gt; type. (&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-12-24-days-of-hackage-text.html&#34;&gt;A 2012 day of hackage
article talks about &lt;code&gt;text&lt;/code&gt;&lt;/a&gt;.)
Since the underlying PCRE C library uses bytes, I generally hand
bytestrings to &lt;code&gt;pcre-heavy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The sample driver code uses lazy I/O to get the lines from input. This
is superficially elegant and concise for pedagogical purposes, but in
real life is a source of resource leaks and other problems and even
causes people to think &amp;ldquo;Haskell is inefficient&amp;rdquo;. For real work, I like
to use &lt;a href=&#34;http://hackage.haskell.org/package/pipes&#34;&gt;&lt;code&gt;pipes&lt;/code&gt;&lt;/a&gt;, which was
covered in another
&lt;a href=&#34;https://ocharles.org.uk/blog/posts/2012-12-16-24-days-of-hackage-pipes.html&#34;&gt;2012 day of Hackage&lt;/a&gt;
and also has an
&lt;a href=&#34;https://hackage.haskell.org/package/pipes-4.1.7/docs/Pipes-Tutorial.html&#34;&gt;extensive, beautiful tutorial&lt;/a&gt;
by its author, Gabriel Gonzalez, who also has a fantastic,
long-running, active blog
&lt;a href=&#34;http://www.haskellforall.com/&#34;&gt;&amp;ldquo;Haskell for all&amp;rdquo;&lt;/a&gt; that every
Haskeller should follow.&lt;/p&gt;

&lt;p&gt;Finally, was a regex the right choice here? It was simple enough for
this problem, but you can see from the ad hoc pattern matching and
hardcoded strings and fragile positional ordering and number of groups
that things could get error-prone really quickly if the regex got any
more complex or we wanted to do proper error handling in case of a
failed match.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Regex support is not a strong point of the Haskell ecosystem, which is
geared to more structured parsing, but there are options if you really
want to use regexes, and I like the Perl-style &lt;code&gt;pcre-light&lt;/code&gt; family of
libraries that now includes &lt;code&gt;pcre-heavy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also, I showed how to add two lines to the top of a Haskell program to
turn it into a Stack script.&lt;/p&gt;

&lt;h3 id=&#34;update-from-day-9:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;(Update from day 9)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;../../blog/2015/12/09/24-days-of-hackage-2015-day-9-template-haskell-goodies-here-interpolate-file-embed/&#34;&gt;Day 9&lt;/a&gt;
covers more libraries based on Template Haskell.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:73f9e85177be1c4a1d48f4dbe8d8b6bf&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>