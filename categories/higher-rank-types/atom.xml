<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Higher Rank Types on The Conscientious Programmer</title>
    <link>http://ConscientiousProgrammer.com/categories/higher-rank-types/</link>
    <description>Recent content in Higher Rank Types on The Conscientious Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Dec 2015 08:00:00 -0500</lastBuildDate>
    <atom:link href="http://ConscientiousProgrammer.com/categories/higher-rank-types/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>24 days of Hackage, 2015: day 6: finding utilities with Hoogle and Hayoo: MissingH, extra</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/06/24-days-of-hackage-2015-day-6-finding-utilities-with-hoogle-and-hayoo-missingh-extra/</link>
      <pubDate>Sun, 06 Dec 2015 08:00:00 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/06/24-days-of-hackage-2015-day-6-finding-utilities-with-hoogle-and-hayoo-missingh-extra/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-6:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Day 6&lt;/h2&gt;

&lt;p&gt;It will never be the case that everything everyone will find useful
will already be in the &amp;ldquo;standard library&amp;rdquo; for any language
ecosystem. However, one of the coolest features of the Haskell
ecosystem (which wows all non-Haskellers when I show them), is the ability to search for useful functions by type
signature, using &lt;a href=&#34;http://hoogle.haskell.org/&#34;&gt;&lt;code&gt;Hoogle&lt;/code&gt;&lt;/a&gt; or
&lt;a href=&#34;http://hayoo.fh-wedel.de/examples&#34;&gt;&lt;code&gt;Hayoo&lt;/code&gt;&lt;/a&gt;. You can use other
criteria also, such as names; this can be useful if you have a guess
at what some useful function might be named.&lt;/p&gt;

&lt;p&gt;There seem to be two philosophies as far as using other people&amp;rsquo;s
utility libraries (or even making one&amp;rsquo;s own to share between different
projects):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reuse is great, let&amp;rsquo;s do it&lt;/li&gt;
&lt;li&gt;every dependency is a potential liability, so it&amp;rsquo;s better to
reinvent, or copy and paste, rather than use something of uncertain
quality or maintainability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I tend to prefer reuse, but there have been times when I have copied
(and even modified) only just what I need, because I don&amp;rsquo;t want the
rest of what is inside a sprawling library that depends transitively
on a whole lot of stuff I don&amp;rsquo;t need. I think this is a granularity
issue. Many people have proposed the idea that since we have a Web
now, in theory the concept of &amp;ldquo;library&amp;rdquo; should go obsolete in favor of
micro-libraries, so to speak, maybe sometimes even to the level of
single standalone functions, and maybe even having a unique
identifier, but this topic is outside the scope of this article. (For
just one idea, check out Gabriel Gonzalez&amp;rsquo;s
&lt;a href=&#34;http://www.haskellforall.com/2015/05/the-internet-of-code.html&#34;&gt;&amp;ldquo;The internet of code&amp;rdquo;&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;The situation is also complicated by the fact that often, so much can
be reinvented with only a couple of lines of Haskell code, so why even
bother looking for someone&amp;rsquo;s implementation of it?&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s assume for this article that you are interested in finding
and using utility libraries. I show how to find some example functions
and reach two utility libraries that I use, very cleverly and
informatively named
&lt;a href=&#34;http://hackage.haskell.org/package/MissingH&#34;&gt;&lt;code&gt;MissingH&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;http://hackage.haskell.org/package/extra&#34;&gt;&lt;code&gt;extra&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;list-string-example:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;List/string example&lt;/h2&gt;

&lt;p&gt;A while ago I was manipulating strings (I was given &lt;code&gt;String&lt;/code&gt;, as
opposed to &lt;code&gt;Text&lt;/code&gt; or &lt;code&gt;ByteString&lt;/code&gt;) and needed to replace all
occurrences of a substring in a file path with a different
substring. For example, as an HSpec test item for a hypothetical
function creatively named &lt;code&gt;replace&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all substrings within a string&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    replace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123abc123abc&amp;quot;&lt;/span&gt; `shouldBe` &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123d123d&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sure, it would not be hard to write code to do this, but why not see
if it&amp;rsquo;s out there already for me to use?&lt;/p&gt;

&lt;p&gt;What type should we search for? Maybe&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;i.e.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;     &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ matching substring&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replacement for the match&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ original string&lt;/span&gt;
&lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ result string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK, let&amp;rsquo;s try this type as a
&lt;a href=&#34;http://hayoo.fh-wedel.de/?query=String+-%3E+String+-%3E+String+-%3E+String&#34;&gt;Hayoo search&lt;/a&gt;. Hmm,
the results are not too promising. At the top is some weird
undocumented regex thing, and that&amp;rsquo;s probably not what we want.&lt;/p&gt;

&lt;h2 id=&#34;an-important-search-technique-make-the-fewest-assumptions:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;An important search technique: make the fewest assumptions&lt;/h2&gt;

&lt;p&gt;Probably the single most important tip for getting good search results
from a type is to make the type as generic as possible: &lt;em&gt;the more type
variables, the better&lt;/em&gt;, and also use only type class constraints you
need. The operation we want is not really
string-specific. Rather, it was a list operation. So the real type we
want is&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This utility function makes the &lt;em&gt;least&lt;/em&gt; assumptions necessary to get
the job done, while working for &lt;code&gt;String&lt;/code&gt; because &lt;code&gt;String&lt;/code&gt; is just
&lt;code&gt;[Char]&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt; is an instance of the &lt;code&gt;Eq&lt;/code&gt; type class. But for the
purpose of replacements, we don&amp;rsquo;t care about whether we&amp;rsquo;re comparing
characters: we only care that whatever element type is involved in
these subsequences, we can compare for equality.&lt;/p&gt;

&lt;p&gt;The
&lt;a href=&#34;http://hayoo.fh-wedel.de/?query=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&#34;&gt;Hayoo search&lt;/a&gt;
immediately brings up much more promising results than with &lt;code&gt;String&lt;/code&gt;,
from packages such as &lt;code&gt;utility-ht&lt;/code&gt;, &lt;code&gt;MissingH&lt;/code&gt;, and &lt;code&gt;extra&lt;/code&gt;. &lt;code&gt;pandoc&lt;/code&gt;
also popped up, but that&amp;rsquo;s a
&lt;a href=&#34;http://pandoc.org/&#34;&gt;huge text-processing tool&lt;/a&gt;, not a library I would
pull in for just one tiny utility function!&lt;/p&gt;

&lt;p&gt;The
&lt;a href=&#34;http://hoogle.haskell.org/?hoogle=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&amp;amp;scope=set%3Astackage&#34;&gt;Hoogle search at &lt;code&gt;hoogle.haskell.org&lt;/code&gt;&lt;/a&gt;
search works pretty well also. (Note that the Hoogle search at the old
site &lt;a href=&#34;https://www.haskell.org/hoogle/?hoogle=Eq+a+%3D%3E+[a]+-%3E+[a]+-%3E+[a]+-%3E+[a]&#34;&gt;gives bad results&lt;/a&gt;.)&lt;/p&gt;

&lt;h2 id=&#34;modifying-our-tests-to-check-the-function-with-the-more-generic-type:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Modifying our tests to check the function with the more generic type&lt;/h2&gt;

&lt;p&gt;I briefly mentioned refactoring HSpec tests on
&lt;a href=&#34;../../blog/2015/12/03/24-days-of-hackage-2015-day-3-hspec-the-importance-of-testing/&#34;&gt;day 3&lt;/a&gt;. Here&amp;rsquo;s
how to test multiple implementations of the same desired function
(let&amp;rsquo;s go with &lt;code&gt;MissingH&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt;), and also test &lt;code&gt;replace&lt;/code&gt; on
different input types: both &lt;code&gt;String&lt;/code&gt; (which is just &lt;code&gt;[Char]&lt;/code&gt;) and &lt;code&gt;[Int]&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MissingHExtraExampleSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | From MissingH&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.Utils&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; ListUtils

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | From extra&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List.Extra&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; ListExtra

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Required for auto-discovery.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;MissingH and extra&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    describeReplace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;MissingH&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ListUtils&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;replace
    describeReplace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;extra&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;ListExtra&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;replace
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;But the following fails to compile! Why?&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Fails to compile!&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ description&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a])  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt; description replace &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe description &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all substrings within a string&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      replace &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;d&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123abc123abc&amp;quot;&lt;/span&gt; `shouldBe` &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;123d123d&amp;quot;&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;replaces all int sublists within an int list&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      replace [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;] [&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;] [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;]
        `shouldBe` [&lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;101&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;102&lt;/span&gt;, &lt;span style=&#34;color: #666666&#34;&gt;4&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;a-note-on-the-critical-use-of-higher-rank-types-for-refactoring:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;A note on the critical use of higher-rank types for refactoring&lt;/h3&gt;

&lt;p&gt;The error message is useful if you know what is going on, but not
useful but if not. Yes, we need higher-rank types.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #888888&#34;&gt;    Illegal polymorphic or qualified type:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    Perhaps you intended to use RankNTypes or Rank2Types&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;    In the type signature for ‘describeReplace’:&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;      describeReplace :: String&lt;/span&gt;
&lt;span style=&#34;color: #888888&#34;&gt;                         -&amp;gt; (Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a] -&amp;gt; [a]) -&amp;gt; Spec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Higher-rank types are a
supported GHC extension discussed in a
&lt;a href=&#34;https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html&#34;&gt;2014 Day of GHC Extensions&lt;/a&gt;. Higher-rank
types are tremendously useful and a feature that is missing from type
systems in most other languages.&lt;/p&gt;

&lt;p&gt;Briefly, the &lt;code&gt;replace&lt;/code&gt; function we want has the type&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;forall&lt;/span&gt; a&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;where we have explicitly quantified the type variable &lt;code&gt;a&lt;/code&gt; so that the
&lt;code&gt;Eq&lt;/code&gt; constraint applies inside its scope. Read the type as &amp;ldquo;for all
types &lt;code&gt;a&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; is a member of the &lt;code&gt;Eq&lt;/code&gt; type class, &lt;code&gt;[a] -&amp;gt;
[a] -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;&amp;rdquo;. Ordinary Haskell without the extension doesn&amp;rsquo;t
allow you to write down this type as a parameter into some function,
because it doesn&amp;rsquo;t have explicit &lt;code&gt;forall&lt;/code&gt; and implicitly inserts a
&lt;code&gt;forall&lt;/code&gt; for you at the top level for everything, but then that is the
wrong scoping for what we want to say.&lt;/p&gt;

&lt;p&gt;So we need to add the directive and change the &lt;code&gt;replace&lt;/code&gt; parameter
type to have explicit quantification, and all is OK:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE RankNTypes #-}&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;describeReplace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;String&lt;/span&gt;  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ description&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (forall a&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Eq&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a])  &lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- ^ replace&lt;/span&gt;
  &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;a-note-on-implicit-quantification-in-haskell-and-related-languages:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;A note on implicit quantification in Haskell and related languages&lt;/h3&gt;

&lt;p&gt;I kind of wish type variable quantification were explicit in Haskell,
i.e., &lt;em&gt;requiring&lt;/em&gt; &lt;code&gt;forall&lt;/code&gt; annotations, as
&lt;a href=&#34;http://www.purescript.org/&#34;&gt;PureScript&lt;/a&gt;
&lt;a href=&#34;https://github.com/purescript/purescript/wiki/Differences-from-Haskell&#34;&gt;does&lt;/a&gt;,
because understanding type variable quantification is important for
fully understanding what is going on at the type level in languages
such as ML and Haskell.&lt;/p&gt;

&lt;p&gt;For example, here&amp;rsquo;s a good article about
&lt;a href=&#34;http://jozefg.bitbucket.org/posts/2015-03-27-unsafe.html&#34;&gt;how to understand the value restriction and monomorphism restriction&lt;/a&gt;,
which can be puzzling if you don&amp;rsquo;t have the mental model of what is going
on underneath.&lt;/p&gt;

&lt;h2 id=&#34;the-joy-of-browsing-libraries:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;The joy of browsing libraries&lt;/h2&gt;

&lt;p&gt;One thing that can happen if you find a utility function useful, is
you can browse around in the module that contains it, or the whole
library, just looking for stuff you might find useful in the
future. For example, I find Neil Mitchell&amp;rsquo;s &lt;code&gt;extra&lt;/code&gt; pleasant enough
(good names and great documentation on Hackage) that I use it when I
can, and I recommend checking it out. The GitHub repo of &lt;code&gt;MissingH&lt;/code&gt;
suggests that it is not really being updated any more, so I&amp;rsquo;m
downplaying my use of it.&lt;/p&gt;

&lt;p&gt;In the world of physical books and magazines, I still go to my local
libraries and browse both the new book/magazine/DVD shelves as well as
the look around on the shelf of an item I find in the stacks to see if
there&amp;rsquo;s something related that I might enjoy checking out.&lt;/p&gt;

&lt;h2 id=&#34;digging-more-deeply:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Digging more deeply&lt;/h2&gt;

&lt;p&gt;Also, note that if you&amp;rsquo;re on the hunt for possibly useful libraries,
but without an immediate need, you can also find them just by looking
at the dependency list that popular libraries already use. I confess
that I have sometimes clicked away on dependencies on a Hackage
page. If you transitively click around on Edward Kmett&amp;rsquo;s
&lt;a href=&#34;https://hackage.haskell.org/package/lens&#34;&gt;&lt;code&gt;lens&lt;/code&gt;&lt;/a&gt; dependencies, you
will reach a huge number of useful libraries, because he is the master
of the universe of code reuse.&lt;/p&gt;

&lt;p&gt;The physical book or paper analogy here, of course, is looking at the
references or bibliography to find more things to read.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;For day 6, I gave an example of how to search for a function on Hoogle
and Hayoo, and go polymorphic for a good result. I recommend using the
quality &lt;code&gt;extra&lt;/code&gt; utility library.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:d5469b5c0bbdfa17c4766f6abf5754f6&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding Clojure transducers through types</title>
      <link>http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/</link>
      <pubDate>Thu, 07 Aug 2014 22:58:16 -0400</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/</guid>
      <description>

&lt;p&gt;Yesterday, Rich Hickey published a blog post, &lt;a href=&#34;http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming&#34;&gt;&amp;ldquo;Transducers are Coming&amp;rdquo;&lt;/a&gt;, which attracted a lot of attention.&lt;/p&gt;

&lt;p&gt;I have a confession to make, which I have made before: I find it very difficult to understand ideas or code not presented with &lt;em&gt;types&lt;/em&gt;. So I decided that the only way I could possibly understand what &amp;ldquo;transducers&amp;rdquo; are would be to actually implement them in a typed language. I ended up doing so and am sharing my findings here.&lt;/p&gt;

&lt;h2 id=&#34;vague-types-in-the-original-blog-post:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Vague types in the original blog post&lt;/h2&gt;

&lt;p&gt;Rich informally gave some type signatures in his blog post:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;;;reducing function signature
whatever, input -&amp;gt; whatever

;;transducer signature
(whatever, input -&amp;gt; whatever) -&amp;gt; (whatever, input -&amp;gt; whatever)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This was, unfortunately, not very helpful. It is hard to make sense of this pseudo-notation for types. What is quantified over what? And what is bound to what? I&amp;rsquo;ll explain later what I mean by these questions.&lt;/p&gt;

&lt;h2 id=&#34;first-discussion-thread-i-saw:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;First discussion thread I saw&lt;/h2&gt;

&lt;p&gt;There was much tweeting online about transducers after Rich Hickey&amp;rsquo;s initial announcement; the tweets did not help me, except for links posted to discussion elsewhere.&lt;/p&gt;

&lt;p&gt;One of them was &lt;a href=&#34;https://news.ycombinator.com/item?id=8143905&#34;&gt;on Hacker News&lt;/a&gt;. I browsed through it but found it mostly not useful. The problem was that although a lot of interesting Haskell code was thrown around, it tended to be &lt;em&gt;related&lt;/em&gt; to transducers but not an &lt;em&gt;exact&lt;/em&gt; translation of the concept. I already had my own intuitions about transducers being related to well-known types such as &lt;a href=&#34;http://www.haskell.org/haskellwiki/Foldable_and_Traversable&#34;&gt;foldables&lt;/a&gt;, &lt;a href=&#34;http://en.wikipedia.org/wiki/Iteratee&#34;&gt;iteratees&lt;/a&gt;, &lt;a href=&#34;https://lens.github.io/&#34;&gt;lenses&lt;/a&gt;, etc. That &amp;ldquo;ordinary function composition&amp;rdquo; was involved immediately suggested the connections, because function composition is huge in these existing Haskell libraries.&lt;/p&gt;

&lt;p&gt;But what I wanted was to understand transducers &lt;em&gt;as they are&lt;/em&gt;, before even thinking about generalizations and comparisons.&lt;/p&gt;

&lt;h3 id=&#34;what-are-the-types:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;What are the types?&lt;/h3&gt;

&lt;p&gt;Rich Hickey &lt;a href=&#34;https://news.ycombinator.com/item?id=8144385&#34;&gt;informally offered some types&lt;/a&gt; (which he said were &amp;ldquo;a la Haskell&amp;rdquo;) to try to help out:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;    ;;reducing fn
    x-&amp;gt;a-&amp;gt;x

    ;;transducer fn
    (x-&amp;gt;a-&amp;gt;x)-&amp;gt;(x-&amp;gt;b-&amp;gt;x)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;OK, by using type variables &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt;, that indicates what is bound to what. The blog post should have used this notation rather than&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;;;transducer signature
(whatever, input -&amp;gt; whatever) -&amp;gt; (whatever, input -&amp;gt; whatever)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;sample-clojure-code:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Sample Clojure code&lt;/h3&gt;

&lt;p&gt;He also posted some sample Clojure code:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/b5aefa622180681e1c81.js&#34;&gt;&lt;/script&gt;


&lt;h2 id=&#34;second-discussion-thread-i-saw:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Second discussion thread I saw&lt;/h2&gt;

&lt;p&gt;Then today, I saw a discussion thread on Reddit, titled &lt;a href=&#34;http://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/&#34;&gt;&amp;ldquo;Clojure&amp;rsquo;s Transducers are Perverse Lenses&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;actual-runnable-haskell-code:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Actual runnable Haskell code&lt;/h3&gt;

&lt;p&gt;Rich finally posted some actual &lt;a href=&#34;http://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/&#34;&gt;type-checked, runnable Haskell code&lt;/a&gt;!&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Transducers in Haskell&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;mapping&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r)
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Original was (b -&amp;gt; a) -&amp;gt; (r -&amp;gt; a -&amp;gt; r) -&amp;gt; (r -&amp;gt; b -&amp;gt; r)&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- but Michael O&amp;#39;Keefe in comment pointed out this is misleading&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;mapping&lt;/span&gt; f xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xf r (f a)

&lt;span style=&#34;color: #0000FF&#34;&gt;filtering&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r)
&lt;span style=&#34;color: #0000FF&#34;&gt;filtering&lt;/span&gt; p xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; p a &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; xf r a &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; r

&lt;span style=&#34;color: #0000FF&#34;&gt;flatmapping&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [b]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r)
&lt;span style=&#34;color: #0000FF&#34;&gt;flatmapping&lt;/span&gt; f xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl xf r (f a)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- for exposition only, yes, conj is gross for lazy lists&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- in Clojure conj and left folds dominate&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;conj&lt;/span&gt; xs x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xs &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; [x]
&lt;span style=&#34;color: #0000FF&#34;&gt;xlist&lt;/span&gt; xf &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl (xf conj) &lt;span style=&#34;color: #B00040&#34;&gt;[]&lt;/span&gt;

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- build any old list function with its transducer, all the same way&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;xmap&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [b]
&lt;span style=&#34;color: #0000FF&#34;&gt;xmap&lt;/span&gt; f &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; mapping f

&lt;span style=&#34;color: #0000FF&#34;&gt;xfilter&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a]
&lt;span style=&#34;color: #0000FF&#34;&gt;xfilter&lt;/span&gt; p &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; filtering p

&lt;span style=&#34;color: #0000FF&#34;&gt;xflatmap&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [b]) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [b]
&lt;span style=&#34;color: #0000FF&#34;&gt;xflatmap&lt;/span&gt; f &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; flatmapping f

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- again, not interesting for lists, but the same transform&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- can be put to use wherever there&amp;#39;s a step fn&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;xform&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r)
&lt;span style=&#34;color: #0000FF&#34;&gt;xform&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; mapping (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; filtering even &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; flatmapping (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;..&lt;/span&gt; x])


&lt;span style=&#34;color: #0000FF&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; xlist xform [&lt;span style=&#34;color: #666666&#34;&gt;1..5&lt;/span&gt;]
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- [0,1,2,0,1,2,3,4,0,1,2,3,4,5,6]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After this post, I knew it would not take me long to figure out transducers.&lt;/p&gt;

&lt;h2 id=&#34;refactoring-his-haskell-code:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Refactoring his Haskell code&lt;/h2&gt;

&lt;p&gt;Two things to notice about the original code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It has long, low-level function types rather than types that actually &lt;em&gt;name&lt;/em&gt; the concepts being discussed (&lt;em&gt;reducers&lt;/em&gt; and &lt;em&gt;transducers&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;It uses hardcoded list types &lt;code&gt;[a]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;type-synonyms-and-higher-rank-types:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Type synonyms and higher-rank types&lt;/h3&gt;

&lt;p&gt;Defining lots and lots of types (whether synonyms or &lt;a href=&#34;http://www.haskell.org/haskellwiki/Newtype&#34;&gt;newtypes&lt;/a&gt; is standard practice when programming in a modern typed language. OK, so I defined a type synonym&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Left reduce&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; a r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; r
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;But what about transducer? This is trickier.&lt;/p&gt;

&lt;p&gt;An &lt;em&gt;invalid&lt;/em&gt; attempt at a type would be&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Illegal!&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; a b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; a r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; b r
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;because the type variable &lt;code&gt;r&lt;/code&gt; is not bound in the type definition. And it would be incorrect to just randomly add &lt;code&gt;r&lt;/code&gt; on the left hand side as an extra parameter to the &lt;code&gt;Transducer&lt;/code&gt; type, because in fact it is &lt;em&gt;critical&lt;/em&gt; that a transducer &lt;em&gt;does not care&lt;/em&gt; about the underlying reducer&amp;rsquo;s return type &lt;code&gt;r&lt;/code&gt;. How do we write the desired type?&lt;/p&gt;

&lt;p&gt;It turns out you need &lt;a href=&#34;http://www.haskell.org/haskellwiki/Rank-N_types&#34;&gt;higher-rank types&lt;/a&gt;. Rank-1 types are not sufficient; we need a rank-2 type to quantify &lt;code&gt;r&lt;/code&gt;, to say that a transducer from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; is a transformation that takes a reducer to a specific &lt;code&gt;r&lt;/code&gt; and returns another reducer to the &lt;em&gt;same&lt;/em&gt; &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Here&amp;#39;s where the rank-2 type is needed&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; a b &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; forall r &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; a r &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; b r
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Now we can see more clearly some &lt;em&gt;completely generic&lt;/em&gt; ways to create a transducer:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;mapping&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; b a
&lt;span style=&#34;color: #0000FF&#34;&gt;mapping&lt;/span&gt; f xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xf r (f a)

&lt;span style=&#34;color: #0000FF&#34;&gt;filtering&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; a a
&lt;span style=&#34;color: #0000FF&#34;&gt;filtering&lt;/span&gt; p xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;if&lt;/span&gt; p a &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;then&lt;/span&gt; xf r a &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;else&lt;/span&gt; r
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;a-bit-of-history:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;A bit of history&lt;/h4&gt;

&lt;p&gt;Higher-rank types are a powerful technique for expressing &amp;ldquo;hiding&amp;rdquo; of unnecessary details about types going on somewhere. My first recollection of the real world use of rank-2 types is from 1994 (the year I started using Haskell, although I did not actually use it in my work as a software engineer until 1995), when I was excited to read a paper by John Launchbury and Simon Peyton Jones that solved, using a rank-2 type, a specific, important, practical problem, &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.3299&#34;&gt;&amp;ldquo;Lazy Functional State Threads&amp;rdquo;&lt;/a&gt;; twenty years later, their &lt;a href=&#34;http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST.html&#34;&gt;ST monad&lt;/a&gt; is still part of the standard library!&lt;/p&gt;

&lt;h3 id=&#34;introducing-type-classes:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Introducing type classes&lt;/h3&gt;

&lt;p&gt;Clojure uses &lt;a href=&#34;http://clojure.org/protocols&#34;&gt;protocols&lt;/a&gt; as an abstraction mechanism, and the &amp;ldquo;magic&amp;rdquo; of transducers uses protocols. In Haskell, type classes are the major abstraction mechanism (this is true of Scala also).&lt;/p&gt;

&lt;p&gt;So I abstracted away from the hardcoded list-oriented functions and values in Rich Hickey&amp;rsquo;s Haskell code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;foldl&lt;/code&gt; abstracted to a &lt;code&gt;class Foldable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conj&lt;/code&gt; and empty list &lt;code&gt;[]&lt;/code&gt; abstracted to a &lt;code&gt;class Conjable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Left fold&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  fold &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; a (f a)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  empty &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; f a
  conj &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Reducer&lt;/span&gt; a (f a)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Note our reliance on transducing and reducing from one type &lt;code&gt;a&lt;/code&gt; to another, &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;foldable-constraint:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;&lt;code&gt;Foldable&lt;/code&gt; constraint&lt;/h4&gt;

&lt;p&gt;Unlike &lt;code&gt;mapping&lt;/code&gt; and &lt;code&gt;filtering&lt;/code&gt;, &lt;code&gt;flatmapping&lt;/code&gt; is &lt;em&gt;not completely generic&lt;/em&gt;, because it depends on something being &lt;code&gt;Foldable&lt;/code&gt; (implementing a &lt;code&gt;fold&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;flatmapping&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; b a
&lt;span style=&#34;color: #0000FF&#34;&gt;flatmapping&lt;/span&gt; f xf r a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; fold xf r (f a)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;conjable-constraint:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;&lt;code&gt;Conjable&lt;/code&gt; constraint&lt;/h4&gt;

&lt;p&gt;Finally, here&amp;rsquo;s the originally list-specific code that now depends only on &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Conjable&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- I changed Rich Hickey&amp;#39;s code to be more general than just list&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- but accept anything Conjable&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;xlist&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f, &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; b a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;span style=&#34;color: #0000FF&#34;&gt;xlist&lt;/span&gt; xf &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; fold (xf conj) empty

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- build any old Foldable function with its transducer, all the same way&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;xmap&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f, &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;span style=&#34;color: #0000FF&#34;&gt;xmap&lt;/span&gt; f &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; mapping f

&lt;span style=&#34;color: #0000FF&#34;&gt;xfilter&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f, &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Bool&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f a
&lt;span style=&#34;color: #0000FF&#34;&gt;xfilter&lt;/span&gt; p &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; filtering p

&lt;span style=&#34;color: #0000FF&#34;&gt;xflatmap&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f, &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f b) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f b
&lt;span style=&#34;color: #0000FF&#34;&gt;xflatmap&lt;/span&gt; f &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; flatmapping f
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;list-specific-stuff:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;List-specific stuff&lt;/h3&gt;

&lt;p&gt;Here is the list-specific code:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Stuff specialized to lists.&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- To use another type, just make it a Foldable and Conjable.&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  fold &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; foldl

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- for exposition only, yes, conj is gross for lazy lists&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- in Clojure conj and left folds dominate&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;[]&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  empty &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;[]&lt;/span&gt;
  conj xs x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xs &lt;span style=&#34;color: #666666&#34;&gt;++&lt;/span&gt; [x]

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Note: the type does not say anything about Foldable or Conjable,&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- even though the implementation just happens to use a list!&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;xform&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Transducer&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;xform&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; mapping (&lt;span style=&#34;color: #666666&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; filtering even &lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt; flatmapping (&lt;span style=&#34;color: #0000FF&#34;&gt;\&lt;/span&gt;x &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span style=&#34;color: #666666&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;..&lt;/span&gt; x])

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Again, this can munge anything Foldable and Conjable, not just a list.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;munge&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; f, &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; f) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt; f &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; f &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;munge&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; xlist xform
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Notice some very important properties of this code:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xform&lt;/code&gt; has a type that does not mention lists at all, even though it is implemented using a list and cannot compile without the list &lt;code&gt;instance&lt;/code&gt; implementations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;munge&lt;/code&gt; also does not mention lists, and can transform anything that is &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Conjable&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- munge a list&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- [0,1,2,0,1,2,3,4,0,1,2,3,4,5,6]&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;example1&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; [&lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt;]
&lt;span style=&#34;color: #0000FF&#34;&gt;example1&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; munge [&lt;span style=&#34;color: #666666&#34;&gt;1..5&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;implementing-another-type-to-illustrate-the-genericity-of-transducers:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Implementing another type to illustrate the genericity of transducers&lt;/h3&gt;

&lt;p&gt;To illustrate Rich Hickey&amp;rsquo;s main point, I implemented instances of &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Conjable&lt;/code&gt; for a standard Haskell &lt;code&gt;Vector&lt;/code&gt; library as an alternate &amp;ldquo;collection-like&amp;rdquo; type.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- For example using Vector instead of list&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Vector&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; V

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- Implement Foldable, Conjable type classes for Vector&lt;/span&gt;
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Foldable&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Vector&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  fold &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;foldl

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;instance&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Conjable&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Vector&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;
  empty &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;empty
  conj &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;snoc
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;And we can run &lt;code&gt;munge&lt;/code&gt; directly on a vector instead of a list, &lt;em&gt;without making any changes&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- return a vector rather than a list; note the fact that munge actually&lt;/span&gt;
&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- internally uses a list&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;example2&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Vector&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Integer&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;example2&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; munge &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;V&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;enumFromN &lt;span style=&#34;color: #666666&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;This is &lt;em&gt;code reuse&lt;/em&gt; at its best.&lt;/p&gt;

&lt;p&gt;Note that there is nothing that ties transducers to any concrete &amp;ldquo;collection&amp;rdquo; type. We could write instances of &lt;code&gt;Foldable&lt;/code&gt; and &lt;code&gt;Conjable&lt;/code&gt; for some kind of &amp;ldquo;channel&amp;rdquo; abstraction, for example, and instantaneously be able to munge data coming from it and to another. In fact, this is already what is done in the real world, where Haskell and Scala are used in production at places like Facebook and Twitter to efficiently handle large amounts of data.&lt;/p&gt;

&lt;h2 id=&#34;my-code-repository:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;My code repository&lt;/h2&gt;

&lt;p&gt;My complete code is available &lt;a href=&#34;https://github.com/FranklinChen/clojure-transducers-in-haskell&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:5a7fb7f4f2a1a2d30fdd2c73dcd9c156&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;It was pretty exciting to see the announcement of the transducers library for Clojure, because it represents a level of abstraction that I think has not been expressed much in the world of dynamically typed languages, although the techniques are two decades old in the Haskell community in a statically typed setting. And I hope that I was able to convey the sheer elegance of Haskell as a way to express interesting types with practical ramifications for abstraction and pluggability.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>