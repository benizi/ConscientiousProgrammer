<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Multiset on The Conscientious Programmer</title>
    <link>http://ConscientiousProgrammer.com/categories/multiset/</link>
    <description>Recent content in Multiset on The Conscientious Programmer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Dec 2015 08:00:00 -0500</lastBuildDate>
    <atom:link href="http://ConscientiousProgrammer.com/categories/multiset/atom/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>24 days of Hackage, 2015: day 8: multiset; I wish this were in the standard containers package</title>
      <link>http://conscientiousprogrammer.com/blog/2015/12/08/24-days-of-hackage-2015-day-8-multiset-i-wish-this-were-in-the-standard-containers-package/</link>
      <pubDate>Tue, 08 Dec 2015 08:00:00 -0500</pubDate>
      
      <guid>http://conscientiousprogrammer.com/blog/2015/12/08/24-days-of-hackage-2015-day-8-multiset-i-wish-this-were-in-the-standard-containers-package/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents-for-the-whole-series:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Table of contents for the whole series&lt;/h2&gt;

&lt;p&gt;A table of contents is at the top of the article for &lt;a href=&#34;../../blog/2015/11/30/haskell-tidbits-24-days-of-hackage-2015-day-1-introduction-and-stack/&#34;&gt;day 1&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;day-8:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Day 8&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t remember when it was, but one day I got sick and tired of
reimplementing in Haskell the same boilerplate logic when keeping
track of many objects classified under the same key. This is a data
structure known as a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Multiset&#34;&gt;multiset&lt;/a&gt;, also known as a
&lt;em&gt;bag&lt;/em&gt;, in contrast with a regular &lt;em&gt;set&lt;/em&gt;, which only keeps track of one
unique object per key.&lt;/p&gt;

&lt;p&gt;I was surprised that by the lack of a multiset module in the standard
&lt;a href=&#34;https://hackage.haskell.org/package/containers&#34;&gt;&lt;code&gt;containers&lt;/code&gt;&lt;/a&gt;
package, although not completely surprised because you can implement a
multiset on top of a set, so in some sense a multiset is
&amp;ldquo;superfluous&amp;rdquo;. Still, I was used to having a multiset available
without any work (however trivial), because of long using a &lt;a href=&#34;http://www.cplusplus.com/reference/set/multiset/&#34;&gt;multiset
in C++&lt;/a&gt;, which I&amp;rsquo;d
used back in the 1990s from the original implementation of the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Standard_Template_Library&#34;&gt;Standard Template Library&lt;/a&gt;,
and also Python&amp;rsquo;s collections library has a
&lt;a href=&#34;https://docs.python.org/2/library/collections.html#collections.Counter&#34;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt;
class which serves a similar purpose.&lt;/p&gt;

&lt;p&gt;Today I&amp;rsquo;ll briefly show some code using &lt;code&gt;multiset&lt;/code&gt; and talk about why
something like this maybe should be in the standard library.&lt;/p&gt;

&lt;h2 id=&#34;the-classic-example-of-multiset-use:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;The classic example of multiset use&lt;/h2&gt;

&lt;p&gt;Multisets are often used for counting things. Word count is a
time-honored use case for multisets, so let&amp;rsquo;s implement a very simple
word count program that break up text into &amp;ldquo;words&amp;rdquo; separated by
spaces, while treating non-letters as spaces, count the words, and
finally output a report which consists of a line for each word and its
count, in descending order of count but ascending order of word.&lt;/p&gt;

&lt;p&gt;For a bit more realism and efficiency even for a toy program, let&amp;rsquo;s
have the input not be &lt;code&gt;String&lt;/code&gt;, but the &lt;code&gt;Text&lt;/code&gt; type from
&lt;code&gt;Data.Text.Lazy&lt;/code&gt; module of the
&lt;a href=&#34;https://hackage.haskell.org/package/text&#34;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt; package. Let&amp;rsquo;s also
build up the final &lt;code&gt;Text&lt;/code&gt; report efficiently.&lt;/p&gt;

&lt;h3 id=&#34;a-sample-hspec-test:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;A sample HSpec test&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s a sample test (for fun you may wish to write a reasonable
QuickCheck generators and tests for this problem). I apologize for the
illegible Haskell multiline string literal; I wish Haskell had
multiline string literals, interpolation, and all that good stuff
other languages have!&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MultisetExampleSpec&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MultisetExample&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;wordCount&lt;/span&gt;)

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;hspec&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;describe&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;it&lt;/span&gt;, &lt;span style=&#34;color: #0000FF&#34;&gt;shouldBe&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Test.Hspec.QuickCheck&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;prop&lt;/span&gt;)

&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;-- | Required for auto-discovery.&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Spec&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;spec&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  describe &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;multiset&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
    it &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;wordCount&amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;$&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;do&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; input &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;I have so   many words; words I so like to have words for!?&amp;quot;&lt;/span&gt;
      &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;let&lt;/span&gt; expected &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;words 3&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;I 2&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;have 2&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;so 2&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;for 1&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;like 1&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;many 1&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n\&lt;/span&gt;
&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;                     \&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;to 1&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;
      wordCount input `shouldBe` expected
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&#34;the-solution:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;The solution&lt;/h3&gt;

&lt;p&gt;The code almost writes itself from a natural language description of
the problem.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #408080; font-style: italic&#34;&gt;{-# LANGUAGE OverloadedStrings #-}&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;MultisetExample&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;where&lt;/span&gt;

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.MultiSet&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; MultiSet
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text.Lazy&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; LazyText
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text.Lazy.Builder&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; LazyBuilder
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Text.Lazy.Builder.Int&lt;/span&gt; (&lt;span style=&#34;color: #0000FF&#34;&gt;decimal&lt;/span&gt;)
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Ord&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;Down&lt;/span&gt;(&lt;span style=&#34;color: #666666&#34;&gt;..&lt;/span&gt;))
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Char&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; Char
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;qualified&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.List&lt;/span&gt; &lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;as&lt;/span&gt; List
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Control.Arrow&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;))
&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color: #0000FF; font-weight: bold&#34;&gt;Data.Monoid&lt;/span&gt; ((&lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt;))

&lt;span style=&#34;color: #0000FF&#34;&gt;wordCount&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;wordCount&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;map replaceNonLetterWithSpace
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;words
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromList
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toOccurList
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;sortOn (snd &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Down&lt;/span&gt;)
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; map summarizeWordCount
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; mconcat
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toLazyText

&lt;span style=&#34;color: #0000FF&#34;&gt;replaceNonLetterWithSpace&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Char&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Char&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;replaceNonLetterWithSpace&lt;/span&gt; c
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Char&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;isLetter c &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; c
  &lt;span style=&#34;color: #666666&#34;&gt;|&lt;/span&gt; otherwise &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;

&lt;span style=&#34;color: #0000FF&#34;&gt;summarizeWordCount&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Occur&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Builder&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;summarizeWordCount&lt;/span&gt; (word, count) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromLazyText word &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; decimal count &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Let&amp;rsquo;s go through this step by step. Note that we&amp;rsquo;re using my favorite
left-to-right composition operator &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; as opposed to the
right-to-left composition operator &lt;code&gt;.&lt;/code&gt; because it looks much more
natural to me for pipelines.&lt;/p&gt;

&lt;h3 id=&#34;get-the-words-from-text:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Get the words from text&lt;/h3&gt;

&lt;p&gt;First, replace all non-letters with spaces for the purpose of this
problem, then use the &lt;code&gt;words&lt;/code&gt; from &lt;code&gt;Data.Text.Lazy&lt;/code&gt; (which we imported
as &lt;code&gt;LazyText&lt;/code&gt;) to break up into words (real tokenization would have
more sophisticated rules). By the way, this is done very efficiently
because GHC performs
&lt;a href=&#34;https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy.html#g:1&#34;&gt;fusion&lt;/a&gt;
in order to do the replacement and the breaking up into words in a
single pass, rather than two as written in the code. Fusion is a
really, really cool optimization that we rely on for our Haskell code
to be super-efficient:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;wordCount&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;map replaceNonLetterWithSpace
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;words
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h3 id=&#34;put-the-words-into-a-multiset:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Put the words into a multiset&lt;/h3&gt;

&lt;p&gt;Next, we get the list words into a multiset. &lt;code&gt;MultiSet&lt;/code&gt; conveniently
has a constructor for that, &lt;a href=&#34;https://hackage.haskell.org/package/multiset-0.3.0/docs/Data-MultiSet.html#v:fromList&#34;&gt;&lt;code&gt;fromList :: Ord a =&amp;gt; [a] -&amp;gt; MultiSet a&lt;/code&gt;&lt;/a&gt;,
and it does this in &lt;code&gt;O(n log n)&lt;/code&gt; time because of the use of comparison
through &lt;code&gt;Ord&lt;/code&gt; to construct a tree (exercise for you if you wish: use
one of the hash table libraries in Hackage to create a
&lt;code&gt;MultiHashSet&lt;/code&gt; instead).&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromList
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;count-the-words:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Count the words&lt;/h4&gt;

&lt;p&gt;We grab a list of word/count pairs (in ascending order of words) using
&lt;a href=&#34;https://hackage.haskell.org/package/multiset-0.3.0/docs/Data-MultiSet.html#v:toOccurList&#34;&gt;&lt;code&gt;toOccurList :: MultiSet a -&amp;gt; [(a, Occur)]&lt;/code&gt;&lt;/a&gt;
where
&lt;a href=&#34;https://hackage.haskell.org/package/multiset-0.3.0/docs/Data-MultiSet.html#t:Occur&#34;&gt;&lt;code&gt;type Occur = Int&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toOccurList
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;sort-the-word-count-list:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Sort the word/count list&lt;/h4&gt;

&lt;p&gt;We sort using the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Schwartzian_transform&#34;&gt;&amp;ldquo;Schwartzian transform&amp;rdquo;&lt;/a&gt;
for efficiency using
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:sortOn&#34;&gt;&lt;code&gt;Data.List.sortOn&lt;/code&gt;&lt;/a&gt;
of type &lt;code&gt;sortOn :: Ord b =&amp;gt; (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt;;
recall we want the count (the second element of the tuple we get back
from the multiset) to be descending.&lt;/p&gt;

&lt;p&gt;Documentation of
&lt;a href=&#34;https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ord.html#t:Down&#34;&gt;&lt;code&gt;Data.Ord.Down&lt;/code&gt;&lt;/a&gt;
explains how this &amp;ldquo;newtype hack&amp;rdquo; is used to change the default
ordering comparison during a sort.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;List&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;sortOn (snd &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Down&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h4 id=&#34;make-a-report-for-each-word-count:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Make a report for each word/count&lt;/h4&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; map summarizeWordCount
  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; mconcat
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;where our summarizing function, for efficiency in avoiding unnecessary
allocations, does not construct a &lt;code&gt;Text&lt;/code&gt; but rather a
&lt;a href=&#34;https://en.wikipedia.org/wiki/Builder_pattern&#34;&gt;builder&lt;/a&gt;, since we
don&amp;rsquo;t need this information for each as &lt;code&gt;Text&lt;/code&gt; but plan to combine the
reports for all the lines into one &lt;code&gt;Text&lt;/code&gt; at the end.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #0000FF&#34;&gt;summarizeWordCount&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; (&lt;span style=&#34;color: #B00040&#34;&gt;LazyText&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Text&lt;/span&gt;, &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Occur&lt;/span&gt;) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color: #B00040&#34;&gt;Builder&lt;/span&gt;
&lt;span style=&#34;color: #0000FF&#34;&gt;summarizeWordCount&lt;/span&gt; (word, count) &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt;
  &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;fromLazyText word &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; decimal count &lt;span style=&#34;color: #666666&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span style=&#34;color: #BB6622; font-weight: bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color: #BA2121&#34;&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;(If you&amp;rsquo;re curious how the builder works, check out the
&lt;a href=&#34;https://hackage.haskell.org/package/text-1.2.1.3/docs/src/Data-Text-Internal-Builder.html&#34;&gt;source code&lt;/a&gt;. It
uses higher-rank types, unsafe operations, and strictness
annotations.)&lt;/p&gt;

&lt;h4 id=&#34;make-the-final-report:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Make the final report&lt;/h4&gt;

&lt;p&gt;Just materialize the &lt;code&gt;Text&lt;/code&gt; from the builder:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;  &lt;span style=&#34;color: #666666&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;LazyBuilder&lt;/span&gt;&lt;span style=&#34;color: #666666&#34;&gt;.&lt;/span&gt;toLazyText
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;h2 id=&#34;what-should-go-into-a-standard-library:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;What should go into a standard library?&lt;/h2&gt;

&lt;p&gt;I mentioned that I think this should go into the standard library, for
convenience. The argument for &lt;em&gt;not&lt;/em&gt; putting something into the
standard library is always, everyone think their useful thing should
be in there, but there&amp;rsquo;s no way that can happen, and so choices have
to be made. Given that, I cannot really argue based on my own
experience or perception of my experience that an entire community
would benefit from my favorite things being made &amp;ldquo;standard&amp;rdquo;. I&amp;rsquo;d like
to think that we have the technology now to collect real data to
determine people&amp;rsquo;s real needs and change the way we make libraries
discoverable and usable. Even something like mining Stack Overflow
questions could bring up many interesting statistics about what people
need. Such data gathering would not substitute for expert curation, of
course, but surely would be useful.&lt;/p&gt;

&lt;p&gt;There is another argument for not having something like multiset be
incorporated: it&amp;rsquo;s easy to implement once you have the regular set. If
you look at the
&lt;a href=&#34;https://hackage.haskell.org/package/multiset-0.3.0/docs/src/Data-MultiSet.html#MultiSet&#34;&gt;source code&lt;/a&gt;,
the following basically says it all. A multiset is just a map from a
key to a count.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34; style=&#34;background: #f8f8f8&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;newtype&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MultiSet&lt;/span&gt; a &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;MS&lt;/span&gt; { unMS &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;::&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Map&lt;/span&gt; a &lt;span style=&#34;color: #B00040&#34;&gt;Occur&lt;/span&gt; }

&lt;span style=&#34;color: #008000; font-weight: bold&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Occur&lt;/span&gt; &lt;span style=&#34;color: #AA22FF; font-weight: bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color: #B00040&#34;&gt;Int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Everything else is a straightforward wrapper.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s like saying a language should not have any syntactic
sugar. I think &amp;ldquo;library sugar&amp;rdquo; is as valuable as syntactic
sugar.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Multisets are useful. You could implement one yourself. Or you could
use the &lt;code&gt;multiset&lt;/code&gt; package someone already wrote for us.&lt;/p&gt;

&lt;h2 id=&#34;all-the-code:2fc978f0a24d72120da8b6255ca644c0&#34;&gt;All the code&lt;/h2&gt;

&lt;p&gt;All my code for my article series are at
&lt;a href=&#34;https://github.com/FranklinChen/twenty-four-days2015-of-hackage&#34;&gt;this GitHub repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>